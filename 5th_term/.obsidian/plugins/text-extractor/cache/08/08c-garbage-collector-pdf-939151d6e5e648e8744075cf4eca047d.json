{"path":".obsidian/plugins/text-extractor/cache/08/08c-garbage-collector-pdf-939151d6e5e648e8744075cf4eca047d.json","text":"Garbage collector 1 Based on the slides of Maurizio Gabbrielli A void dangling references • Dangling references are a source of bugs difficult to understand • Possible solutions: – Detect the Dangling Reference at the time of the dereference: – Tombstones – Locks and Keys – Prevent the user from releasing the memory • Automatic recovery of unused space: – Garbage collection » Reference count » Mark and Sweep » ... Tombstones • Heavy in space (and time) • Invalid tombstones remain allocated (add counter?) • Allocated in Special Memory (Cemetery)4 Locks and Keys • Lock = word in memory with arbitrary value • Key = initialized with lock value • Heavy (never used by default) • Used in Pascal when dynamic control of dangling references is required • A void accumulated problem of tombstones (memory can be reused) Garbage Collection • The user freely allocates memory • Not allowed to deallocate memory • The system periodically retrieves the allocated memory and no longer usable – Not usable = without a valid access path Reference CountReference count • Each allocated object has a (inaccessible) counter ref_count • Creation: new (p) ref_count(p^) := 1; • q := p ref_count(q^) := ref_count(q^) - 1; ref_count(p^) := ref_count(p^) +1; • Return from proc P: – For each pointer r local to P: ref_count(^r) := ref_count(^r) - 1; • When ref_count (object)=0, object is retrieved; recursively decrement ref_count of any other data whose pointer resides in the object • Problems: waste of space; recognize what a pointer is; does not recover circular structures Circular structuresGarbage Collection: Mark and Sweep 1. Make all objects on the heap as unused 2. Starting with pointers outside the heap, visits all the concatenated structures, marking each object as used 3. Retrieve all remaining objects from the heap unused • To use when free memory is low • T ime proportional to the total length of heap • Use wisely the space on the stack (point 2) – When the GC runs the space is limited!: pointer reversal (Schorr and W aite) • Stop-the-world effect: When the space is retrieved the user experiences a significant slowdown in the system reaction – Incremental GC (e.g., Java) Stack for the visit 1 1 Pointer reversal • Mark and Sweep creates fragmentation • Solution: Mark and Compact – live objects are moved so they are contiguous – requires more than one pass on the heap → expensive • Copy (only) – no explicit \"mark garbage\" phase – heap divided in two ■ normal execution → only one used ■ memory finish → copy Mark and Compact & CopyStop and CopyCheney's algorithm, CopyHomework • Chapter 8, exercises 8-12","libVersion":"0.0.0","langs":"","hash":"","size":0}