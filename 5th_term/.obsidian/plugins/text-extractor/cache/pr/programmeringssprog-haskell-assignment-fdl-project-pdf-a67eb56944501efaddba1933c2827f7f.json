{"path":".obsidian/plugins/text-extractor/cache/pr/programmeringssprog-haskell-assignment-fdl-project-pdf-a67eb56944501efaddba1933c2827f7f.json","text":"DM 552 Programming Languages Spring 2023 Project Department of Mathematics and Computer Science University of Southern Denmark March 18, 2023 2 Introduction The purpose of the project for DM552 is to try in practice the use of lfunc- tional programming for small but non-trivial examples. Please make sure to read this entire note before starting your work on this project. Pay close attention to the sections on deadlines, deliverables, and exam rules. Exam Rules This project is a part of the portfolio exam, and it has to be passed to pass the overall exam. The project must be performed in groups of 1 to 2 members, and no cooperation is allowed beyond what is explicitly stated in this document. Groups of 2 members have to solve all 4 tasks, while groups of 1 members only need to solve 3 tasks. Deliverables The deliverable for this project. A short project report in PDF format (max 5 pages without front page and appendix) has to be delivered. This report should contain the following 7 sections: • front page • speciﬁcation • design • implementation • testing • conclusion • appendix including all source code The report has to be delivered as a single PDF ﬁle electronically using the SDU’s Digital Exam platform. Deadlines Pre-delivery 21 April 2023 Final delivery 2 June 2023 3 The Problem Fractals are geometric objects that are similar to themselves on arbitrarily small scales. There are many examples of fractals in nature, and they form some of the most beautiful structures you can ﬁnd. One example is snowﬂakes, but also lightning has a fractal structure. Another example are ferns, where each part is similar to the whole. Many fractals can be generated by using so-called L-Systems. These sys- tems describe a start state (depth 0) and a set of rules how to evolve a state into a state of larger depth. For more background on L-Systems, have a look at the Wikipedia article: http://en.wikipedia.org/wiki/L-system For example, to generate a Koch curve, we start with the initial (depth 0) state F signifying a forward move, i.e., a straight line. The rule for expanding to the next depth is given as a replacement rule. F -> F L F R F L F where L is a 60 degree turn to the left and R is a 120 degree turn to the right. That is, we replace a straight line by a straight line, a left-turn, a straight line, a sharp right-turn, a straight line, a left-turn, and a fourth and ﬁnal straight line. Thus, the state for depth 1 is F L F R F L F. To get to depth 2, we have to apply the rule again to all positions of the state where it is possible, i.e., we have to replace each of the four F by F L F R F L F. The result is F L F R F L F L F L F R F L F R F L F R F L F L F L F R F L F where the new sections are underlined to aid your understanding. To get to depth 3, we would have to replace each of the 16 Fs by the right side of the rule. For the sake of brevity, I leave this exercise to you. In general, if there is more than one rule, all rules need to be applied in parallel. That is, all letters, for which there is a rule, need to be replaced by the rules’ right-hand sides at the same time to go from depth n to depth n + 1. Letters, for which there is rule deﬁned are copied into the new state. 4 Let us take a look at the ﬁle koch.fdl available from the project section of the course home page. start F rule F -> F L F R F L F length 2 depth 5 cmd F fd cmd L lt 60 cmd R rt 120 The ﬁrst line gives the start state, i.e., the state F for depth 0. The second line give the only rule needed for the Koch curve, i.e., to replace F by F L F R F L F. The third line speciﬁes the length of each segment, i.e., each straight line will be 2 units long. The fourth line speciﬁes that states should be ex- panded to depth 5 before drawing the frac- tal. Finally, the Lines 5 to 7 specify that F is a straight line, L is a 60 degree left-turn and R is a 120 degree right-turn. Task 0 – Preparation Clone the git repository from https://github.com/peter-sk/fdl, install GHC and HGL, and test the framework: git clone https://github.com/peter-sk/fdl.git scripts/linux.sh #or scripts/mac.sh ghci fdl.hs -e ’runGraphics (withWindow_ \"Test\" (1000, 600) \\ (\\ w -> drawIt (w, 500, 300, 0, 50) [Forward, RightTurn 90, \\ Forward, RightTurn 90, Forward, RightTurn 90, Forward] >> getKey w))’ You should see a window with a white square on a black background. Then inspect the FDL ﬁles in the examples directory. Task 1 – Applying Rules to a State Your ﬁrst task is to write a function apply :: State -> [Rule] -> State that takes a state (i.e., a sequence of letters) and applies to each letter of this state the ﬁrst applicable rule from the list of rules. As speciﬁed before, letters that have no applicable rules are copied to the new state. This function corresponds to going from depth n to depth n + 1. Test your function by calling it with the following command: apply \"FXRYF\" [Rule ’X’ \"XRYF\", Rule ’Y’ \"FXLY\"] This should produce the following result: \"FXRYFRFXLYF\" 5 Task 2 – Going to Target Depth Your second task is to write a function expand :: State -> [Rule] -> Int -> State that takes an initial state, a set of rules, and a tar- get depth. Using your apply function, it has to apply the rules repeatedly in parallel until the target depth is reached. This function corresponds to going from depth 0 to depth n. Test your function by call- ing it with the following command: expand \"FX\" [Rule ’X’ \"XRYF\", Rule ’Y’ \"FXLY\"] 2 This should again produce the following result: \"FXRYFRFXLYF\" Task 3 – Processing a Fractal Your third task is to write a function process :: Fractal -> [Command] that takes a value of type Fractal and produces a list of commands to draw the fractal. Your function needs to ﬁrst use expand to get the state for the target depth. Then it should use the function of type Char -> Command of the fractal to map the state into a list of values of type Command. This function corresponds to trans- lating a fractal description into a list of turtle graphics commands. Test your function by calling it with the following command: main This should produce a white-on-black version of the snowﬂake as shown on Page 3, i.e., of three Koch curves put together. Also test your code using the other .fdl ﬁles and include screenshots in your reports. 6 Task 4* – Support for Line Widths and Colors The fractals look nice enough, but some colors and wider lines would make them more pretty. Your challenge task is to extend the Fractal Descripton language by the commands color and width where color gets a color name, a color code or “random” as an argument while width gets a ﬂoat. In order to accomplish this, you need to read more about the functionality of the Haskell Graphics Library: http://hackage.haskell.org/package/HGL Here is an example for a nicer dragon curve: start F X rule X -> X R Y F rule Y -> F X L Y length 3 depth 13 color random width 2.0 cmd F fd cmd X nop cmd Y nop cmd L lt 90 cmd R rt 90 Note that this task is optional for groups of 1 members and mandatory for groups of 2 members.","libVersion":"0.0.0","langs":"","hash":"","size":0}