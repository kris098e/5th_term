{"path":".obsidian/plugins/text-extractor/cache/01/01-abstract-machine-pdf-88b870045f12e0c0dfc334065ddfa3dc.json","text":"Abstract Machines, Interpreters, Compilers 1 Based on the slides of Maurizio Gabbrielli 2 One Machine, One language – One physical machine exists to run its language – Language and machine come together • A machine corresponds to its language • A language can be run from multiple machines – Heart of a physical machine: • The fundamental cycle fetch-decode-execute 3 Abstract machine • An Abstract Machine (AM) is a set of data structures and algorithms that can store and run programs • Abstraction of the concept of a physical computer 4 Interpreter ● Component that interprets instructions ● The structure of the interpreter is the same for any AM ● AM ~ Store + Interpreter 5 Machine language • M → Abstract machine • L M → Machine language of M • L M It is the language that is \"understood\" by the interpreter of M – The programs are special primitive data on which the interpreter works 6 The Hardware Machine • A conventional processor is a (very concrete form of) Abstract Machine • Its language is the machine language M L M M 7 Chinese boxes L Mb Mb Ma L Ma 8 Making an abstract machine Different ways: 1. Realization in Hardware 2. Emulation or simulation via Firmware 3. Interpretation or simulation via Software 1 is always theoretically possible but • Used only for low-level machines or dedicated machines • Maximum speed • No flexibility 9 Making an abstract machine Different ways: 1. Realization in Hardware 2. Emulation or simulation via Firmware 3. Interpretation or simulation via Software 2: data structures and algorithms but realized by micro-programs, residing in a read-only memory • Microprogrammable (physical) machine • High speed • Greater flexibility than pure HW . 10 Different ways: 1. Realization in Hardware 2. Emulation or simulation via Firmware 3. Interpretation or simulation via Software 3: data structures and algorithms of the abstract machine but realized through programs written in the language of the host machine • Any Host machine works • Less speed • Maximum flexibility. Making an abstract machine 11 • Partial Function: f: A → B Correspondence between elements of A and B that can be undefined on some a ∈ A • P L indicates a program written in the language L • P L performs a partial function More Formally. What is a Program? 12 Purely Interpretative Implementation M L is developed writing an interpreter of L that runs on M0 13 Purely Compilative Implementation • The programs in L are translated to L0 programs • T ranslation made by other program C La L, L0 The compiler from L To L0 written in La 14 Pure compilative Implementation, 2 15 Compilation or interpretation? • Pure Interpretative Implementation: – Poor machine efficiency M L – Good flexibility and portability – Easy to run-time interaction (e.g. debugging) • Pure Compilative Implementation: – Difficult, given the distance between L and L0 – Good efficiency: • cost-decoding compiler load • Each instruction is translated only once – Low flexibility – Loss of information on the structure (abstraction) of the source program – More memory of product code (these days it does not matter that much) 16 In the real world Both techniques coexist 1) Some instructions (e.g. input/output) are always interpreted 2) Programs are translated in internal representation or intermediate code 17 Example of interpretive type: Java Java AM M0 Byte Code L AM = Java L M0 = Bytecode M0 = JVM M = suitable machine running the interpreter of the JVM Build M Interpretation 18 Example of compilative type: C L AM = C L Mo = Code generated by compiler M0 =? M seems pointless: it coincides with M0? CAM MoBuild M Interpretation 19 Implementation of compilative type : C CA M MoBuild M Interpretation L AM = C L Mo = Language generated by compiler + Support for memory management, I/O etc. Mo = M + interpreter for run-time support calls M = host Machine 20 What to translate and what to interpret • In principle: – T ranslation for those constructs of L that correspond closely to constructs of L0 ; – Simulation for others. • Compilative T ype Solution – Privileges efficiency • Interpretive type Solution – Privileges flexibility 21 Real languages • Languages typically implemented in a compilative way – C, C++, Fortran, Pascal, ADA • Languages typically implemented in an interpretive way – LISP, ML, Perl, Postscript, Prolog, Smalltalk, Java, Python 22 Just-in-time compilation ( not in the book!) • AKA dynamic translation or run-time compilation • Bytecode translation to machine code at run time (more difficult if from source code) • JIT compiler analyses the code being executed and translates parts of the code where you can obtain a speedup – can be done per-file, per-function or arbitrary code fragment – code cached and reused later without needing to be recompiled – sometimes better performance than static compilation (some optimization only possible at runtime) • Combines the speed of compiled code with the flexibility of interpretation • JIT causes a delay in the initial execution (warm-up time) • Classical example is the JIT compilers for Java, browsers for JavaScript 23 Partial Evaluation If you know part of the input of a program P that program can be Specialized. Conditional evaluation: (knowing we have X = 3 in input) If x > 1 then A else B → A Symbolic Evaluation Expressions: 20 + x-22 → x-2 (for each value of x) 20 + x-22 → 1 (knowing that x = 3 input) 24 Partial Evaluation • P L (X, Y) Program with input data X and Y, written in the language L 25 First Futamura projection - Peval L0 (X, Y) Partial evaluator for language L0 - Int L0 L1 Language interpreter for L1, written in L0 - P L1 Program written in L1 - D Program Data Consider a specific program P1 L1 If we do the partial evaluation of Int L0 L1 specializing it for P1 what happens? Peval L0 (Int L0 L1 , P1 L1 ) ? 26 First Futamura projection - Peval L0 (X, Y) Partial evaluator for language L0 - Int L0 L1 Language interpreter for L1, written in L0 - P L1 Program written in L1 - D Program Data Consider a specific program P1 L1 If we do the partial evaluation of Int L0 L1 specializing it for P1 what happens? Peval L0 (Int L0 L1 , P1 L1 ) = P1' L0 And by definition of Peval you have Int L0 L1 (P1 L1 , D) = P1' L0 (D) W e have produced a program P1' L0 (D), written in L0, which is functionally equivalent to Int L0 L1 (P1 L1, D) and then (by definition of interpreter) to P1 L1 (D). W e have compiled (and specialized) P1 L1 from L1 to L0.27 Second projection of Futamura • Peval L0 L0 Partial evaluator for language L0 W ritten in L0 • Int L0 L1 Interpreter of L1 W ritten in L0 • P L1 Program written in L1 • As it Peval L0 L0 is written in L0 we can apply it to itself • W e then make partial evaluation of the partial evaluator, specializing it for the interpreter Peval L0 L0 (Peval L0 L0 ,Int L0 L1 ) What happens? 28 Second projection of Futamura • Peval L0 L0 Partial evaluator for language L0 W ritten in L0 • Int L0 L1 Interpreter of L1 W ritten in L0 • P L1 Program written in L1 • Peval L0 L0 (Peval L0 L0 ,Int L0 L1 ) = R L0 • And you have that R L0 L0 (P L1 ) = Peval L0 L0 (Int L0 L1 P L1 ) • W e have produced a program R L0 written in L0, which if applied to a program P L1 (written in in L1 ) produces a program written in L0 which is equivalent to the partial evaluation of the interpreter on P L1 and so (for the first projection) is equivalent to P L1 W e got a Compiler from L1 to L0! 29 Third projection of Futamura Peval L0 L0 Partial evaluator for language L0 ... Peval L0 L0 (Peval L0 L0 , Peval L0 L0 ) What did we get? → Homework :) 30 Exercises Exercises from the PL book 1.3, 1.5, 1.6, 1.7 Hint: for exercise 6 if you do not know where to start see slides below 31 Pascal compiler generation: bootstrapping • The first Pascal environments included – A Pascal compiler from Pascal to P-code: C Pascal Pascal, P-Code – The same compiler, translated into P-code: C P-Code Pascal, P-Code – An interpreter for P-code, written in Pascal: I Pascal P-code • To have a local implementation on a MO specification: – Produce (by hand) a translation of I Pascal P-code in the language of M0: I L0 P-code • Run a Pascal P program on Mo: I L0 P-code ( C P-Code Pascal, P-Code , P) = P ', in P-code I L0 P-code (P ', x) = desired result Can we do better? 32 Compiler generation: bootstrapping • Improve efficiency, with a compiler written in L0 • By hand, starting from C Pascal Pascal, P-Code produce C Pascal Pascal,L0 • Now we have: – C Pascal Pascal, P-Code – C P-Code Pascal, P-Code – I Pascal P-code – I L0 P-code – C Pascal Pascal,L0 • Bootstrapping I L0 P-code ( C P-Code Pascal, P-Code , C Pascal Pascal,L0 ) = C P-Code Pascal,Lo I L0 P-code ( C P-Code Pascal,Lo ,C Pascal Pascal,L0 ) = C L0 Pascal,L0","libVersion":"0.0.0","langs":"","hash":"","size":0}