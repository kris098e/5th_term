{"path":".obsidian/plugins/text-extractor/cache/05/05a-implementing-scoping-1-pdf-524089862d419bca92a01a691fd390e1.json","text":"Implementing scoping rules 1 Based on the slides of Maurizio Gabbrielli 2 Implementing scope rules • Static Scope – Static chain – Display • Dynamic Scope – A-List – Central Referencing Environment Table (CR T) 3 How do you determine the correct link? • The Code of foo must always access the same variable x • This x is stored in a certain AR (in this case in the Main ) • At the top of the stack we have the AR of foo (because foo is running) foo fie X Main X First case: foo called in fie foo Main X Second case: foo called from main {int x = 10; void foo () { x++; } void fie () { Int x = 0; foo (); } fie (); foo (); } 4 Activation Record for static scoping • Dynamic Link: – Pointer to previous AR on stack (caller AR) • Static Link: – Pointer to the AR block that immediately contains the text of the running block Static Link Dynamic Link • Dynamic link depends on the sequence of execution of the program • Static link depends on static nesting (in text) of procedure declarations 5 Static Chain: Example • Sequence of calls to run time A, B, C, D, E, C Static links If a sub-program is nested at the level K , then the chain is long K 6 Allocation of tasks • Compiler: – Associates the information K at every call – Associates to every name an index K: • K = 0: local name • K ≠ 0: Non-local name defined h blocks above • Costs – For every access to a non-local variable • K static chain steps more than access to a local 7 W e try to reduce costs: the Display • Display [i] = pointer to AR of procedure level i, last active • Sequence of Calls: A, B, C, D, E, C Saved Display 8 Display With Display , an object is found with two accesses: one for the display and one for the object 9 Display or static chain? • Rare depth nesting > 3, so max length of static chain = 3 • Optimization techniques can improve access to frequently used chains (keeping pointers in registers) • The display is more expensive to maintain than the static chain in the call sequence... • Conclusion: display little used in modern implementations... 10 Dynamic Scope • With dynamic scope the name-object association depends on – the flow of control at run-time – the order in which the sub-programmes are called • The general rule is simple: the current binding for a name is the last one determined in the execution (not yet destroyed) 11 Obvious implementation • Storing names in AR • Search by name going up the stack • Example: Calls to, B, C, D In gray associations Inactive 12 V ariant: A-List • The associations are stored in a special structure, used like a stack • Example: Calls to, B, C, D 13 A-List costs • V ery easy to implement • Occupation Memory: – names explicitly present • Cost of management – entering and exiting from the block • inserting/removing blocks on the stack • Access time – Always linear in the depth of the A-list Can we do it better? 14 Central referencing table (CR T) • A void long scans of A-list • A table maintains all the distinguished names of the program – If the names are known statically, you can access the table element in constant time – Otherwise, hash access • Each name is associated with the list of associations of that name – The most recent is the first – The others (deactivated) follow • Constant access time 15 Example (CR T) • Example: Calls to, A, B, C, D 16 CR T with hidden stack • Example: Calls to A, B, C, D Evolution of the CR T Evolution of the hidden stack 17 CR T costs • More complex management than A-List • Less memory occupancy: – If names are statically known, names are not needed – In any case, each name stored only once • Cost of management – entering and exiting from the block • managing all lists of names defined in the block • Access time – Constant (two indirect accesses) 18 Suggested Exercises ● Chapter 5 exercises 1,2,3,4,6","libVersion":"0.0.0","langs":"","hash":"","size":0}