# VERY IMPORTANT:
- In the residual network, after an iteration, the bottleneck ark will be filled to its capacity with flow, and in the next calculated residual network, this ark will only point backward. 
	- see the example on the residual network of a network. 
		- there is an ark going back to the vertex which has the flow of the inital flow going out from the vertex. The ark going out from the vertex is the $capacity-flow$
- The flow of the system is bounded by all of the cuts you can make, meaning it is bounded by the lowest cut you can make.
	- so if you find a cut which is equal to the flow value, then you are guranteed that it is the maximum.
		- this is because it cannot be larger than the smallest cut. The cut is bounded by the capacity of the arks going from `S to T`. 
			- remember the flow value may also be less than the capacity of the cut. Thereby it is not guranteed you can find a flow of the network with the value of the smallest cut.
- the `ark going backward` is the ark which is made by the residual network, when you want to cancel out the flow
	- that is, the ark which goes in the opposite direction of the ark there originally was in `N`.
## Figure out
why the running time is as stated on the last slide.
# notes
![[Pasted image 20231102080441.png]]
The $N=(v,E,c)$ is
- c = capacitiy function
- E = edges
- v = vertices.

- Capacity function assigns an ark a value in the reals
- flow is a function that assign a value to an ark which  between 0 and the capacity function.
- balance is the amount of flow going out **minus** the flow coming in.
![[Pasted image 20231102080827.png]]
- The balance of the entire graph must be 0, as an ark will contribute possitively to one verticy while it contributes negatively to another 
# ST-flows
still looking at the picture above. 
- just a flow where only 1 verticy has positive flow, and only 1 verticy has negative flow, which is precisely matching the flow of the positive verticy. The rest of the vertices has `0` flow.
![[Pasted image 20231102081603.png]]
- The value of the flow is just the balance of `s` and `-bf(t)`. As all of the other vertices has balance 0. And `t` should match what comes out of of `s`
## Example
Note that the `capacity` is what is the blue. and the flow is `red`. We cannot increase the flow further than the `capacity`. 
![[Pasted image 20231102082041.png]]
### Maximal and maximum
- A flow is maximal if we cannot increase the flow without also decreasing some edges.
![[Pasted image 20231102082439.png]]
#### Intuition of finding the maximal flow
![[maximum_st_flow.excalidraw]]
- We see that `3` and `4` blocks the flow to be larger than `7` since the only way to get out of the node on lowest node is capacity of `3` and we cannot send more than `4` out from the top.
![[Pasted image 20231102084311.png]]

## Notation for the cut
![[Pasted image 20231102120601.png]]
The capacity is the sum of all the capacities going from `S to T`. 
![[Pasted image 20231102120857.png]]
This state that the value of the flow for the network is it flow from S to T, minus the flow that gets back to S again.
- the drawing for the cut has the flow of 6: $2+4+3-2-1=6$.
> Notes to the proof
> The only vertex in S that has a positive balance (The rest are 0 or less) is little s.
> So, $|f|=b_{f}(s)-flow\ coming\ back\ \\to\ s$. Next we just write out the definition of the balance. 
> **see the illustration for why we can calculate the flow for the system like this**

- So, we see that every arch that stays in `S` is contributing `0` to the flow of the system, as it goes from a verticy in `S`, contributing positively, but negatively to another verticy in the same set.
- Only the flows going out from S contribute positively, but negatively when going in.
	- As `S` contains the little s, that means we should subtract the flow from `S` by the flow from `T` and not vice versa. This is because, flow is created from `S` with little `s` which positively, while `T` contains `t` which only contributes negatively.
![[Pasted image 20231102121638.png]]
![[Pasted image 20231102122505.png]]
- Of course the flow is bounded by the capacity as this is the max it can be
- the least amount the flow of `f(T,S)` is 0 (it can be $\geq$ 0), we want to subtract the least possible
	- The scenatio where it is equal to 0 only happens when dont send something back to `S`. And the capacity can at max be the capacity.
- **When making the (S,T)-cut, the flow is bounded by the capacity of the arks coming out of S**
### Illustration
![[Pasted image 20231102122955.png]]
- As the cut goes over the flow of `4, 3` the flow we send out is `4+3=7=c(S,T)` therefore we have reached the maximum.
- we dont count the one going from little `s` to the lower node, as this contributes `0` in the network `S`.
- how to get to the maximum flow, we need to know about residual networks
# Residual networks 
![[Pasted image 20231102124620.png]]
Still have the same vertices, have a selected arkset,  and a new capacity function
- if there exist a flow from `u to v` then it is the `c(u,v) - f(u,v)` else if the flow goes against, i.e from `v to u` then it is the flow from `f(v,u)`. else 0 as there is no ark at all between these two vertices.
- look at the $N_{f}$. It is what the residual network looks like after performing the operation on the network on the right. It is now just a path from `s to t` with only arks going towards t
![[Pasted image 20231102125313.png]]
- $\delta_{+}(P)$ is the minimum flow on the arc on any forward ark, calculated by the formula for residual networks
- $\delta_{\_}(P)$ is the minimum of any ark going back.

- This means that we can find the minimum by just making the residual network, and find the minimum value on the ark form `s to t`.
![[Pasted image 20231102125910.png]]
- **this preserves the flow of the network, still satisfying the conditions for a (s,t) network**
- in the network we can increase the flow that goes out from vertice by the $\delta$ we just found, and decrease it by $\delta$. We have flow conservation, since we now ensure that the one extra flow from `s` sends out one more, the intermediate vertice will cancel til out again by sending more, meaning we still satisfy that the balance of the vertice in the middel between `s` and `t` are still 0. 
	- look at the 3rd vertice, this also receives $+\delta$ on one side and $-\delta$  on the other, preserving the flow
		- look at the different scenarios. 
			- verticy has in-out: stays the same, + out and - out
			- in-in: + on one side, but this has also been reduce on out the other side
			- out-out: - on one side, + on the other.
![[Pasted image 20231102135844.png]]
This an illustration of the method. We have the initial network, then we start using the methods to get the residual network. `s` we see that we apply the formula $c(v,u) - f(v,u)$ and get `5`. We do this all around. We then take the minimum of all the paths, which is `2`. We can then, to the going out cases, add 2 to the flow, and the ones going in we subtract 2. 
> Note that we add the backwards edge to cancel the outgoing out with the ingoing
> this means that fx for s, when using the function we will get 6-1=5 out, but we add an ingoing to be 1 to cancel the previous out.
> thats also why we only have the ingoing ark 4 on the top of s, since it should be 4-4=0 out.

# Ford Folkerson method
![[Pasted image 20231102142125.png]]
1. set all flows to 0 for all arcs
2. constructing $N_{f}$ is just the original network. This is because all flows are 0, so we just have all the capacities on each ark with no flow
3. find a path from `s to t`
4. make the residual network and find the $\delta$
	1. Important that you look at how we calculated this. There is a picture somewhat above this showing the calculation of $C_{f}$
	2. Note that since the flows are 0, we will just find the bottleneck in the capacities in the first iteration
	3. 
5. update the flows on the arks
6. find the flow
7. put flows into the arks
In each iteration we update the value of the flow by delta
## Will this terminate?
- We can only prove this because the capacities are of integer values.
- since we increase the flow by at least 1 in each iteration, then we can at max do {sum of capacities from s} rounds, since this is the only node we can get flow into the system from.
![[Pasted image 20231102174210.png]]
## Is this flow a maximum flow?
![[Pasted image 20231102174231.png]]
### Proving 2 implies 1
If we still have an augmenting path when we are done, that means we can still increase the flow in the network, meaning the network was in fact not a maximum flow to begin with.
### Proving 3 implies 1
- Look at the first graph. This corresponds to no augmenting path / (S,T)-path left. There is no way to get to T from S. This is due to the capacity function for residual network. If we have flow=capacity for an ark, then there is only an ark going back, with the capacity = flow.
- in the `graph for N (not the residual)` we then, as explained before, going towards T the `f=c`, and on the ones going back to S we have `f=0`.
- 
![[Pasted image 20231103113019.png]]
## running time
![[Pasted image 20231102180046.png]]
Since we do the minimum of the flows out and the flows in, we will have to repeat the algorithm $2 \cdot10^{10}$ times.
This happens when we only increase the flow by `1` each iteration
- This means we will want to pick an algorithm here that fx did not choose the path downwards, but just took the path that had $10^{10}$.
### Run better algorithm for the path finder, edmonds and karp
![[Pasted image 20231102180707.png]]
- only keep the args that goes forward through the layers
![[Pasted image 20231102184248.png]]
- As we only keep the args that goes forward, we will not be able to take the newly introduced arks when we recalculate the residual network. 
- At some time in the future, the path from `s to t` will have increased, as the edges which has the flow=capacity for the ark will have been turned around, and there will not a forward ark anymore
![[Pasted image 20231102184557.png]]
![[Pasted image 20231102184932.png]]
- **At least one ark is flipped for every iteration where we augment the flows.**

# Integrality theorem
# biparte
## wiliam fiset
If we increase the capacity of the ark for S to the person, that means that person can now get multiple books, which we dont want
![[Pasted image 20231114065330.png]]
![[Pasted image 20231114065432.png]]
![[Pasted image 20231114065703.png]]
![[Pasted image 20231114065729.png]]
## Lecture and notes
- having a matching of some cardinality, means you make a network with the same flow.
### Integrality theorem
For all flows `f(u,v)` where $u,v\in V$, in the network, this flow is nonnegative and har integers. Can be 0.
#### Theorem
Every d-regular bipartite graph `G=(X,Y,E)` has a perfect matching
![[Pasted image 20231114075520.png]]
#### Proof
This is where we have the scenario of all verticies in `X` and `Y` has the same edge-degree. This means that $\mid X\mid=\mid Y\mid$ since $\mid E\mid=d\mid X\mid=d\mid Y\mid$. This means we have the capacity of 1 from `s` to all `X` and 1 to `t` from all `Y`. This also means we can put $\frac{1}{d}$ flow on all arcs going from `X->Y`. Now, we apply the `Integrality theorem`, where we run the maximum flow algorithm on it. This will end up giving all nonnegative integer flow on all arcs, and `1` from all `X->Y` but for each vertex in `X` only a single arc from `X->Y` will have a 1. This will utilize all of the capacities. These are nonnegative integers since the algorithm can only increase by the smallest capacity, not less, which is 1, in each itteration.
**This uses the collary: can just read the initial** 
explanation: the cardinality of a maximum matching means we only look at the vertices involved. So, `|X|`, or `|Y|` as `|X|=|Y|`. This makes sense since we use all of the arcs, but cannot use existing in use vertices from `X`. So all vertices in `X` is used, and each have an arc going out with to `Y` with a flow value of `1` 
![[Pasted image 20231114081507.png]]
# having network with balances of inner nodes larger than 0
just introduce a `super source` and `super sink`
**ugeseddel 9 1.3** 

# converting graphs to digraphs
**ugeseddel 9 1.4**
all about getting a certain digraph to look like another digraph, which was formed by the same graph??
