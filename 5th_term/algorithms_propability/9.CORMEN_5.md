# 5.1-5.3
![[Pasted image 20231114082424.png]]
![[Pasted image 20231114082503.png]]
Firing a person means we have to pay some fee, meaning we want to fire as few as possible during the hiring.

![[Pasted image 20231114082558.png]]
it says $c_{h}$ as the _cost for hire_ not $e_{h}$. This is used again lower.
![[Pasted image 20231114082720.png]]
The probability of hiring the person _i_ is $\frac{1}{i}$ since it is at random.
![[Pasted image 20231114083147.png]]
![[Pasted image 20231114083300.png]]
Since we want to get this expected value, we also need to find the random permutation of the interviews.
![[Pasted image 20231114083448.png]]
One way is this algorithm, where we assign a certain priority to each of the interviews at random, between `1 and n^3`. And then sort. We will see why $n^3$ is important, and why it works well under certain conditions.
![[Pasted image 20231114083818.png]]
1. the probability that two interviews get the same priority is $\frac{1}{n^3}$. 
2. Let `A` denote the event that there are interviews that gets the same priority. Summing over the entire sample space
3. The probability of the event happening is the union over all of the possible clashes.
	1. Where we can use the union bound
4. ${ n \choose 2} < n^2$
5. Therefore the probability of the event not happening, i.e no clashes, is $\geq 1-\frac{1}{n}$
![[Pasted image 20231114090152.png]]
The probability the permutation we have made with the algorithm is $\frac{1}{n!}$
![[Pasted image 20231114090238.png]]
![[Pasted image 20231114090250.png]]
Probability of the first key being on the position is was at at the start is $\frac{1}{n}$ the 2nd key will then have 1 less to choose from, meaning the probability will be $\frac{1}{n-1}$...
![[Pasted image 20231114090438.png]]
![[Pasted image 20231114090635.png]]
- The permute by sorting runs in $O(n \cdot \log(n))$, but there may colissions. This means we have to run the algorithm again.
- The expected number of repetitions of the geometric distributions is $\frac{1}{p}$, and since the probability of having clashes is $1-\frac{1}{n}$ we get the expected number of times we run the algorithm is $\leq 2$.
We want to do better than this.
![[Pasted image 20231114091040.png]]
![[Pasted image 20231114091132.png]]
![[Pasted image 20231114091336.png]]
This is just the permutation of `n` elements where we only take `k` of the `n` elements, and we care about the ordering.![[Pasted image 20231114093947.png]]
![[Pasted image 20231114093959.png]]
We can start with `i=1 or i=2`
**i=1**
![[Pasted image 20231114094128.png]]
**i=2**
![[Pasted image 20231114094255.png]]
just before the 2nd iteration, the probability that the first element is still in place is $\frac{1}{n}$. 
![[Pasted image 20231114094506.png]]
It is really just a matter of using the same logic as before **in my opinion**, probability of the first one being in the same place is $\frac{1}{n}$, the 2nd one has only $n-1$ places to choose from so that is $\frac{1}{n-1}$ and we just multiply them together, by using the rules for $p(E_{1}|E_{2}\dots)$

- We want the invariant to be true at all times, and prove the base case at first. When having `i=1` then the probability of having that permutation is simply 1.
- we then want to see the invariant holds when we increase `i`.
	- we do this by multiplying $\frac{1}{n-i+1}$ onto the invariant for the previous loop
![[Pasted image 20231114094650.png]]
![[Pasted image 20231114094702.png]]

![[Pasted image 20231114094727.png]]

# 5.4.1-5.4.3
![[Pasted image 20231114100037.png]]
Note that the probability of `i and j` having the same birthday is $\frac{1}{n}$ since we first fix on `i`, then `j` has `n` possibilities left, and the possibility of hitting the same as `i` is then $\frac{1}{n}$.  We can pick these pairs in ${ k \choose 2}$ ways. Since we have to choose `k` people, and we choose `2` of the persons to have the same birthday.
![[Pasted image 20231114100755.png]]
