- LL(1) means, left-to-right and left-most-varibale, the 1 means look ahead 1
- LR(1) means, left-to-right and right-most-variable, the 1 means the same
- LALR(1) same as before, with LA=look ahead
# Pattern
## Repeat
use specific rules
### Until
No more information
## Examples
[[Modern-Compiler-Implementation-in-C.pdf#page=58]]
`NULL,FIRST,FOLLOW`
A "null first follow" context-free grammar is not a standard term in formal language theory or context-free grammar theory. However, it's possible you may be referring to two different concepts related to context-free grammars: nullable symbols and FIRST and FOLLOW sets. Let me explain each of these concepts:

1. Nullable Symbols:
    
    - Nullable symbols in a context-free grammar are non-terminal symbols that can derive the empty string (ε). In other words, if a non-terminal symbol can produce ε as a derivation, it is considered nullable.
    - Nullable symbols play a role in parsing because they can be used to handle optional parts of a production.
2. FIRST Set:
    
    - The FIRST set of a non-terminal or terminal symbol in a context-free grammar consists of all the terminal symbols that can appear as the first symbol in a string derived from that symbol. It also includes ε (the empty string) if the symbol can derive ε as a valid derivation.
    - Calculating the FIRST set is important for predictive parsing (LL(1)) to determine which production to use based on the next input symbol.
3. FOLLOW Set:
    
    - The FOLLOW set of a non-terminal symbol in a context-free grammar consists of all the terminal symbols that can immediately follow that non-terminal symbol in a valid derivation.
    - Calculating the FOLLOW set is important for predictive parsing (LL(1)) to resolve parsing decisions, such as which production to apply when there are multiple choices.

In the context of a context-free grammar, you might need to compute the nullable symbols, FIRST sets, and FOLLOW sets to facilitate parsing. These concepts help ensure that a parser can correctly and unambiguously recognize and parse a language defined by the grammar.

If you have a specific grammar or problem related to these concepts, please provide more details, and I can offer more targeted assistance.
### NULL
can we terminate
### FIRST
What we can get first in a string, i.e the first char, by following the syntax
### FOLLOW
# Top down parser (simple, not for compilers)
**In the parser-tree, it is from top to bottom, and then left to right in this tree**

Follow the parser table, and always take the left most option and use that rule.
![[Pasted image 20230929154620.png]]
FIRST(y) it is the set of terminals which begin the string from y.

Use the parser tree, and use `FIRST, FOLLOW, NULL` in a clever way to reach to the bottom
![[Pasted image 20230927093956.png]]
The input is the one in top. Use the given rule 
1. if input $\in$ FIRST(input)
2. or if input is NULLABLE, and $t\in$ FOLLOW(X|Y|Z)
if it works we add it to LL(input)
# bottom-up parsers (used for most compilers)
## What is the behaviour we want
- Go from right to left, and try to get to the start symbol. If we can get here, then we will accept.
- This uses some grammar
- We take what is on the right side and replace it with what is on the left side, to get it reduced to the start symbol
![[Pasted image 20231002123008.png]]
- Uses parser table
![[Pasted image 20231002123344.png]]
- $s_{4}$ means shift and go to state `4` in the grammar.
- $g_{11}$ means go to state `11` and write whatever in the input?
- $r_{5}$ means reduce with rule `5`
- blank states are `reject-states`

## Making a bottom-up parser
![[Pasted image 20231002124603.png]]
Start symbol only appears once, else reduce it to only 1 start symbol
### make a DFA
added a 
- `.` meaning we haven't gotten anywhere yet
- `?` means a lookahead symbol
from `.` we will add all of the rules with E on the left-hand side.

- Creating what is below comes from taking the rule, take the `.` and move it to the symbol on the right from it, and do it for all the rules
- When we get a `.` behind something with a rule, we begin to apply it, and we do it in the same table. Fx see the one which has **`+` going downward**

> if we have a lookahead symbol, it is called LR(1), what is down below is LR(0)

![[Pasted image 20231002124722.png]]
![[Pasted image 20231002133101.png]]
- This can be reduced
	- But reducing the input will provide less states, and it may provide poor debugging information, as the one with more states will maybe fail sooner than the one that is reduced

# Recursive-descent parser
create functions for each of the non-terminals
