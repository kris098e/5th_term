[[notes-code-generation.pdf]]
[[slides-code-generation.pdf]]
![[Code_generation.excalidraw]]

- Have an AST that contains the entire program.
- Also has a symbol table for the program
	- one box for each scope
	- In the AST if we fx have a function, it has a pointer to the correct symbol table

# Invariants
Makes it much easier to write compilers, if we always make sure certain  invariants are satisfied at all times
## Concrete invariants in SCIL
- stack is used heavily, fx all arguments on the stack
- 
# Stack frame in SCIL
- grows upwards
## Stack frame protocols in SCIL
- use common conventions for entering a function, fx push caller-save registers
	- caller-save, the caller is responsible for having the correct values in the registers after the function
	- callee-save, the function has to make sure the registers are as they were before the call to the function 
	- push parameters
	- push static link
- **look at how the stack looks like in the example at page `5, 7`**
# Examples
## First_assembler.s
```armasm
  
# We want to add 42 and 45 and print the result.  We need to engage in
# the protocols to transfer control from the OS to us and later back
# again (the first callee prologue and last callee epilogue).  We also
# need to transfer control to printf and later back again (the caller
# prologue and epilogue).

# The purpose here is to show the complete conventions for the elements
# involved in this example; in many cases optimizations (removal of code
# lines) are possible.

.data                         # Ensuring that data cannot be executed as code

form:
        .string	"%d\n"

.text                         # Switching to the code segment

.globl main
main:
                              # CALLEE PROLOGUE
        pushq %rbp	      # saving base pointer
        movq %rsp,%rbp	      # making stack pointer new base pointer
	pushq %rbx	      # %rbx is "callee save"
	pushq %r12	      # %r12 is "callee save"
	pushq %r13	      # %r13 is "callee save"
	pushq %r14	      # %r14 is "callee save"
	pushq %r15	      # %r15 is "callee save"

                              # COMPUTATION BEGINS
	movq $42, %rbx	      # rbx := 42
	addq $45, %rbx	      # rbx := 45 + rbx

                              # CALLER PROLOGUE
			      # %rax is return value; should not be in use
	pushq %rcx	      # %rcx is "caller save"
	pushq %rdx	      # %rdx is "caller save"
	pushq %rsi	      # %rsi is "caller save"
	pushq %rdi	      # %rdi is "caller save"
	pushq %r8	      # %r8 is "caller save"
	pushq %r9	      # %r9 is "caller save"
	pushq %r10	      # %r10 is "caller save"
	pushq %r11	      # %r11 is "caller save"

                              # PASSING ARGUMENTS AND CALLING PRINTF
	leaq form(%rip), %rdi # passing 1. argument in %rdi
        movq %rbx, %rsi	      # passing 2. argument in %rsi
                              # Further arguments would be passed in
                              # rdx, rcx, r8, r9, and then the stack
        movq $0, %rax         # no floating point registers used
        testq $15, %rsp       # test for 16 byte alignment
        jz sba                # jump if aligned
        addq $-8, %rsp        # 16 byte aligning
        callq printf@plt      # call printf
        addq $8, %rsp         # reverting alignment
        jmp endsba
sba:
        callq printf@plt      # call printf
endsba:


                              # CALLER EPILOGUE
	popq %r11	      # restoring "caller save" register
	popq %r10	      # restoring "caller save" register
        popq %r9              # restoring "caller save" register
	popq %r8	      # restoring "caller save" register
	popq %rdi	      # restoring "caller save" register
	popq %rsi	      # restoring "caller save" register
	popq %rdx	      # restoring "caller save" register
	popq %rcx	      # restoring "caller save" register

                              # CALLEE EPILOGUE
	popq %r15	      # restoring "callee save" register
	popq %r14	      # restoring "callee save" register
	popq %r13	      # restoring "callee save" register
	popq %r12	      # restoring "callee save" register
	popq %rbx	      # restoring "callee save" register
        popq %rbp	      # restoring base pointer
        movq $0, %rax         # return "no error" exit code
        ret		      # return from call
```

## Hand_coded_factorial.s
```armasm
.data

form:
        .string	"%d\n"

.text

fac:
				# Callee prologue
	pushq %rbp		# Saving base pointer
	movq %rsp,%rbp		# Making stack pointer new base pointer
	
	movq 16(%rbp),%rax	# Assigning argument 1 to %rax; SL was omitted
	cmp $0,%rax		# Comparing %rax to the constant 0
	jne else		# Jump to else if not equal
	movq $1,%rax		# Assigning the result (the constant 1) to %rax
	jmp end			# Jump to end
else:
        pushq %rax              # Save argument for after the recursive calls
	addq $-1,%rax		# Adding -1 to %rax
	
				# Caller prologue
	pushq %rax		# Pushing %rax (1. argument)
	call fac		# Automatically pushes return address
				# Caller epilogue
	addq $8,%rsp		# Popping argument off stack
				# By convention, return value is now in %rax
	
	popq %rdx		# Move earlier saved original argument to %rdx
	imulq %rdx,%rax		# %rax = %rdx * %rax ~ n * fac(n-1)
end:
				# Callee epilogue
	popq %rbp		# Restoring base pointer
	ret			# Return from call

.globl main
main:				# Program starts here
				# Callee prologue
	pushq %rbp		# Saving base pointer
	movq %rsp,%rbp		# Making stack pointer new base pointer

				# Caller prologue
	pushq $5		# Pushing the constant 5 (1. argument)
        call fac		# Automatically pushes return address
                                # Caller epilogue
	addq $8,%rsp		# Popping argument off stack
				# By convention, return value is now in %rax

				# Caller prologue
 	leaq form(%rip), %rdi	# Passing string address (1. argument)
	movq %rax,%rsi		# Passing %rax (2. argument)
        movq $0, %rax           # No floating point registers used
        testq $15, %rsp         # Test for 16 byte alignment
        jz sba                  # Jump if aligned
        addq $-8, %rsp          # 16 byte aligning
        callq printf@plt        # Call printf
        addq $8, %rsp           # Reverting alignment
        jmp endsba
sba:
        callq printf@plt        # Call printf
endsba:
				# Caller epilogue (empty)

				# Callee epilogue
	popq %rbp		# Restoring base pointer
        movq $0, %rax           # Return "no error" exit code
	ret			# Return from call
```
