[[06-compiler.pdf]]

remember to read the code and understand the code, as this will help a lot
# Compiler phases
page 3
## Frontend
error detection, `ensuring the program is correct`
### Scanner
takes input program character by character, returns tokens of interest
- Clashes in expression matching will be resolved by
	1. Longest matching
	2. Which comes first in the `lex` file
Look at the example for the `if` or `id`. If there are more than just `if` we accept it as an `ID`.
![[Pasted image 20240121135131.png]]
- Make this into a NFA
[[06-compiler.pdf#page=16]]
- convert to DFA
[[06-compiler.pdf#page=17]]
#### Uses Lex / Flex
`(how to run)` [[06-compiler.pdf#page=21]]
![[Pasted image 20240121141333.png]]
```c
%{
#include <stdio.h>
%}

%option noyywrap

%%
[ \t\n]+        printf("white space, length %i\n",yyleng);
 
"*"             printf("times\n");
"/"             printf("div\n");
"+"             printf("plus\n");
"-"             printf("minus\n");
"("             printf("left parenthesis\n");
")"             printf("right parenthesis\n");
 
0|([1-9][0-9]*) printf("integer constant: %s\n",yytext);
[a-zA-Z_][a-zA-Z0-9_]* printf("identifier: %s\n",yytext);

.               printf("illegal char %s\n",yytext);
%%
void main() {
  yylex();
}
```

### Parser
takes the tokens, are these allowed in the programming language and are they correctly placed
### Symbol Collection
identifiers collection
### Type checking
staticly done before, or begin executing
## Back end
Generate the ouput
### Code generation
produce assembler code or other output we want.
here we can also do some optimization
### Emit
finally emit the code which can be ran, or the output

