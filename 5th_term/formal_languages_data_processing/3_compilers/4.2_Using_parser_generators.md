# yacc
## grammar
![[Pasted image 20231004122258.png]]
## How to write the parser
![[Pasted image 20231004122304.png]]
## The syntax and parser for grammar 3.30
![[Pasted image 20231004122326.png]]
![[Pasted image 20231004122925.png]]
## errors
When using `yacc` and there conflicts such as
1. shift-reduce
2. reduce-reduce
`yacc` will output a file with the errors, these should be handled, but sometimes they do not cause any actual error on execution

yacc handles this by, by default whenever the issue 
1. shift-reduce. Handles by shifting
2. reduce-reduce. Handles by taking the first rule seen in the language
## Presedence
These are helpful in solving conflicts.
Have the options 
1. `%left` - left associative, meaning that what is on the left binds tighter
2. `%right` - right associate, right binds harder
3. `%nonassoc` - does not matter
4. `%uminus` - bind the hardest, used as`(-6) * 8, not -(6 * 8).`
Now these are either `rule or token`-favoured. if they are token favoured then we shift more often, and if rule favoured then we reduce more often.
![[Pasted image 20231004125214.png]]
## SYNTAX VERSUS SEMANTICS
Some input can be accepted by the syntax of the grammar, but will have to be discarded in the `semantic`-part of the compiler. 
### Example, arithmetic and boolean syntax
Grammar
![[Pasted image 20231004131323.png]]
The expressions `a + 5&b` is legal, but will have to be rejected at a later state with some `sematic-error`


# Bison
[[bison_parsser.pdf]]
- more clean than `yacc`, but is a successor to this
# Options for bison
see page 7
- report the DFA
- give tokens for flex
## Output file from bison
shows the DFA with its states and what to do on certain inputs in each state
- `$default` means _otherwise_
	- meaning that we will take the first rules, or otherwise if not taking the symbols, then do the default
	- This happens on `conflicts`
- Bison defaults to shifting? on shift-reduce conflicts
## Ambiguity
If having conflicts, we can rewrite the grammar, or we can choose to default to `shift` or `reducing`. Having `reduce/reduce` problems, we can choose the first rule met fx.
### Precedence
Can define precedence rules, to know which step to take.

1. If having **left-associative precedence**, means we should reduce before moving forward on the input. 
2. Having **right-associative precedence** means we will shift 
3. **non-associative** means we will raise an error
![[Pasted image 20231005090117.png]]
### Stack machine
## Code generation
- The companion code for the grammar is only executed when we reduce
- `$$` is just associating the grammar rule with a certain value, which fx can be a struct.
## Streamed use
Parse expression with lexer, put the output into bison and then run the c-code.
