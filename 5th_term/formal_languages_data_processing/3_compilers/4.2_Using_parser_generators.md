# Motivation
## What the streamlined use of lexer and bison does
The lexer file does not contain any main function, so it cannot be run as a standalone program. Instead, it is meant to be used with a parser generated by a tool like Yacc or Bison. The parser would call the lexer to get the next token, and then use that token to decide what to do next.
## In whole
The lexer and parser are two parts of a compiler that work together to interpret the source code. They are not run sequentially, but rather, they operate simultaneously in a pipeline.

The lexer (or scanner) takes the source code as input and breaks it down into individual tokens. These tokens are the smallest units of meaning in the language, such as keywords, identifiers, operators, etc. The lexer then feeds these tokens one by one to the parser [oreilly.com](https://www.oreilly.com/library/view/flex-bison/9780596805418/ch01.html).

The parser takes these tokens from the lexer and checks them against the grammar rules to construct a parse tree, which represents the syntactic structure of the program. The parser doesn't need to know the exact values of the tokens, just their types (as defined by the lexer) [gnu.org](https://www.gnu.org/s/bison/manual/bison.html).

In your case, you first run the lexer on your source code. This will generate a sequence of tokens. Then, you run the parser on this sequence of tokens. The parser will check these tokens against the grammar rules defined in your Bison file to construct a parse tree [docs.google.com](https://docs.google.com/presentation/d/1aOmtI88ydlsqwHNdAGWtZasdGq-b8JiI7lTmOHvogqs/htmlpresent).

In summary, you first run the lexer on your source code, and then you run the parser on the output of the lexer. They are not run separately, but in a pipeline. The lexer tokenizes the source code, and the parser checks these tokens against the grammar rules to construct a parse tree.
# yacc
## grammar
![[Pasted image 20231004122258.png]]
## How to write the parser
![[Pasted image 20231004122304.png]]
## The syntax and parser for grammar 3.30
![[Pasted image 20231004122326.png]]
![[Pasted image 20231004122925.png]]
## errors
When using `yacc` and there conflicts such as
1. shift-reduce
2. reduce-reduce
`yacc` will output a file with the errors, these should be handled, but sometimes they do not cause any actual error on execution

yacc handles this by, by default whenever the issue 
1. shift-reduce. Handles by shifting
2. reduce-reduce. Handles by taking the first rule seen in the language
## Presedence
These are helpful in solving conflicts.
Have the options 
1. `%left` - left associative, meaning that what is on the left binds tighter
2. `%right` - right associate, right binds harder
3. `%nonassoc` - does not matter
4. `%uminus` - bind the hardest, used as`(-6) * 8, not -(6 * 8).`
Now these are either `rule or token`-favoured. if they are token favoured then we shift more often, and if rule favoured then we reduce more often.
![[Pasted image 20231004125214.png]]
## SYNTAX VERSUS SEMANTICS
Some input can be accepted by the syntax of the grammar, but will have to be discarded in the `semantic`-part of the compiler. 
### Example, arithmetic and boolean syntax
Grammar
![[Pasted image 20231004131323.png]]
The expressions `a + 5&b` is legal, but will have to be rejected at a later state with some `sematic-error`


# Bison
[[bison_parsser.pdf]]
- more clean than `yacc`, but is a successor to this
# Options for bison
see page 7
- report the DFA
- give tokens for flex
## Output file from bison
shows the DFA with its states and what to do on certain inputs in each state
- `$default` means _otherwise_
	- meaning that we will take the first rules, or otherwise if not taking the symbols, then do the default
	- This happens on `conflicts`
- Bison defaults to shifting? on shift-reduce conflicts
## Ambiguity
If having conflicts, we can rewrite the grammar, or we can choose to default to `shift` or `reducing`. Having `reduce/reduce` problems, we can choose the first rule met fx.
### Precedence
Can define precedence rules, to know which step to take.

1. If having **left-associative precedence**, means we should reduce before moving forward on the input. 
2. Having **right-associative precedence** means we will shift 
3. **non-associative** means we will raise an error
![[Pasted image 20231005090117.png]]
### Stack machine
## Code generation
- The companion code for the grammar is only executed when we reduce
- `$$` is just associating the grammar rule with a certain value, which fx can be a struct.
## Streamed use
Parse expression with lexer, put the output into bison and then run the c-code.
