# Type checking
- can give entire courses in type checking.
- different techniques are used for each
	- logic based programming languages
	- functional programming languages
	- object oriented languages
# Structured data
- arrays
- records
- objects
# Garbage collection
becomes relevant when you have some structured data
# Optimisation techniques
- have to choose the right algorithm when compiling
	- does not matter that much if the assembly code is fast
- 
## Peephole optimisation
- notice things that are done inefficiently
	- optimize it
- not allowed to provide different behaviour
	- fx not allowed to correct errors

- match on patterns in the code
	- replace certain patterns with optimized code
		- when we are done, we go over the file again, since the changed can maybe be optimized again
### Why didnt we just write better code to begin with
- have to generate boiler plate code, so that we have program which is reliable to begin with.
- we cannot assume much in the `code_generation/emit`-phase.
	- since we have to write code that works for every possible scenario, we make the simplest case. Then we can optimize afterwards
## Register allocation (Not relevant for the exam)
- how to use the registers more efficiently
### Example
```asm
mov $42, T1
op *, T1
mov y, T2
mov z, T3
mov T2, T4
op T1, T4
mov $87, T5
```
1. Assume we have infinitely many registers
2. livesness
	1. Look where the registers are used.
		1. fx T2 is live during 
```
mov y, T2
mov z, T3
mov T2, T4
```
3. liveness analyzes
	1. use a graph
4. compute `in, out` sets for each node, where a node represent some piece of code.
	1. `in` registers that needs to be used in the node
	2. `out` ?

## Stack usage
- much faster to use stack than fx memory
