The file [`participants.txt`](https://imada.sdu.dk/u/kslarsen/dm565/Files/participants.txt) will be used in many of the next examples. It will be useful to save your results (direct output to a file), since some results are reused as input in later exercises.

1. Use the command-line tool `sort` to sort on the first names. Which effect does `sort -k2` have? Now sort on the email addresses.
``` ouput
Marie Gabriele Christ Email: machr14@student.sdu.dk
Sushmita Gupta Email: sugup13@student.sdu.dk
Lars Jacobsen Email: lajac01@student.sdu.dk
Abyayananda Maiti Email: abmai13@student.sdu.dk
Anders Nicolai Knudsen Email: anknu18@student.sdu.dk
Morten Nyhave Nielsen Email: monie02@student.sdu.dk
Martin Rud Ehmsen Email: maehm10@student.sdu.dk
Jens Svalgaard Kohrt Email: jeko404@student.sdu.dk
BÃ¡rÃ°ur Ãrantsson Email: baara07@student.sdu.dk
```
- sorts on the 2nd column
- sort on email: `sort -k2 -t:`
	- `-t` specifiies which token should be the seperator
1. Use `tr` twice to delete ":" and change "@" to "$".
	1. `cat participants.txt | tr -d ":" | tr @ $`
2. Use `cut` several times to remove anything other than the user name, i.e., first remove `@student.sdu.dk`, and then continue.
	1. `CAT participants.txt | cut -f1 -d'@' | cut -f2 -d':' | tr -d " "`
		1. -f to keep the column, left or right to it
3. Make a file with as many copies of the line `@student.sdu.dk` as there are lines in the original file. You can of course find out how many lines are needed using `wc`. ツ One way to create that file is to use `seq n`, where `n` is the number of lines you need, followed by an appropriate `sed` substitution using a regular expression. Now `paste` this file together with the file of user names from above to create full email addresses again.
	1. `seq 9 | sed "s/.*/@student.sdu.dk/"`
	2. `paste users.txt mail.txt`
4. Use `gawk` to put a line number and a colon in front of the full emails from above. Remove the space following the colon in the original file, and then `join` these two results on the email address field.
	1. 
5. Consider the UTF-8 encoded files from last time. Using command-line tools, place a filter before `wc` so that characters (allowing the Danish ones) are counted, as opposed to counting bytes, as `wc` does.
	1. As fx `å` counts for 2 bytes, we want to make it only 1 byte, so can use all characters which uses 1 byte
	2. `cat file | sed -E 's/./a/g'` 
		1. Here we use the `g` to do it for all characters that meets it, instead of on each line
7. Consider the different end-of-line formats from last time. Write `sed` code that translates from MS-DOS to Unix style and the other way around.
	1. MS-DOS uses `\r\n` as new lines
	2. Want to remove the `\r`
		1. `cat file | sed -E 's/\r//'`
8. Mask credit card numbers so that `1234 5678 9012 3456` becomes `**** **** **** 3456`.
	1. `cat file | sed -E 's/([[:digit:]]{4} ){3} [0-9]{4}/**** **** **** \1/g'`
			1. here we do `g` such that we can have multiple cards on the same line
9. With input
    Name,Team,First Test,Second Test,Third Test
    Tom,Red,5,17,22
    Joe,Green,3,14,22
    Maria,Blue,6,18,21
    Fred,Blue,2,15,23
    Carlos,Red,-1,15,24
    Phuong,Green,7,19,21
    Enrique,Green,3,16,20
    Nancy,Red,9,12,24
    
    use `gawk` to create individual, test, and team averages (`-1` represents a non-existing result and should simply be ignored) as
    
    Name         Average
    ----         -------
    Tom            14.67
    Joe            13.00
    Maria          15.00
    Fred           13.33
    Carlos         19.50
    Phuong         15.67
    Enrique        13.00
    Nancy          15.00
    ----------------------
    Average, Test 1:  5.00
    Average, Test 2: 15.75
    Average, Test 3: 22.12
    ----------------------
    Average, Red:    16.00
    Average, Blue:   14.17
    Average, Green:  13.89
    
    Write the program on a script file and run using the `-f` option to `gawk`. Do not try to write the entire program from the beginning. Start by printing the names, then try to compute the average of each individual and print that, and so on. This is proptotyping! The formatting is the least important.
```java
# Initialize variables
BEGIN {
    FS = ","
    OFS = "\t"
    test1_sum = 0
    test2_sum = 0
    test3_sum = 0
}

# Process each line
{
    name = $1
    team = $2
    test1 = $3
    test2 = $4
    test3 = $5

    # Calculate individual averages and count for valid test scores
    if (test1 >= 0) {
        test1_sum += test1
        test1_count++
    }
    if (test2 >= 0) {
        test2_sum += test2
        test2_count++
    }
    if (test3 >= 0) {
        test3_sum += test3
        test3_count++
    }

    # Calculate team averages
    team_total[team] += (test1 + test2 + test3)
    team_count[team]++
}

# Print individual averages
END {
    print "Name", "Average"
    print "----", "-------"

    for (name in test1_total) {
        if (test1_count[name] > 0) {
            avg = test1_total[name] / test1_count[name]
            printf "%-12s %.2f\n", name, avg
        }
    }

    print "----------------------"
    printf "Average, Test 1: %.2f\n", test1_sum / test1_count
    printf "Average, Test 2: %.2f\n", test2_sum / test2_count
    printf "Average, Test 3: %.2f\n", test3_sum / test3_count
    print "----------------------"

    for (team in team_total) {
        avg = team_total[team] / team_count[team]
        printf "Average, %s: %.2f\n", team, avg
    }
}
```
1. What happens if the field separator is the empty string? Write an `gawk` script that counts occurrences of the normal (English) letters and digits and writes each letter and digit and the number of times it occurred. Now to use this for programs, only count in lines that are not comment lines (you can decide what a comment line starts with). Thus, you have to use a pattern.
![[Pasted image 20230928094756.png]]
1. Use `tr`, `sort`, and `uniq` to take an input (text) file and produce a list of words and their frequencies in the text sorted in order of highest frequencies first.

`cat file |tr -d "?\"" |tr -s " .," "\n" |sort |uniq -c |sort -r`
delete characters we dont want, then squeese and repeat with `tr` basically just if we meet `.....` it will be translated to just `\n`, and also this `...,.,,.,` will be squeesed into just `\n`.
We have to sort before we use `uniq`, `-c` counts.
