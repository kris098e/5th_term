![[Pasted image 20230910070747.png]]
![[DFA.excalidraw]]
# I
![[Pasted image 20230912110453.png]]
![[Pasted image 20230912110439.png]]

![[Pasted image 20230910104621.png]]
a. since we accept exactly this language, we must, when swapping the accept state accept everything that is not that language. Since we have a finite automata, it will still be a regular language. 

b. .
![[NFA_Complement.excalidraw]]
If we take the complement we still recognise 0, so it does not necesarrily produce the complement of the languange

As an NFA can always be made to a DFA, it is still closed under this operation

![[Pasted image 20230910105014.png]]
Just means that we go from one letter in a to the next in b, then to the next in a and then to the next in b, and so on ...

![[Pasted image 20230912114336.png]]
C is the token, i.e which machine we are to go to next.

![[Pasted image 20230910105721.png]]



![[Pasted image 20230913112159.png]]
![[Pasted image 20230913112214.png]]
even number of as's
[[DFA_even_a.excalidraw]], **This is a horrible solution, as we can end up with just 2 states, basicly removing 2\*8 states**
[[1or2Bs.excalidraw]]

The approach is that we follow each transition from the two DFAs, we start til `q00` meaning we are in state 0 in the first DFA and 0 in the 2nd. If we get an `a` then we will see which state we are in the 1st DFA and the 2nd. If the 1st will lead to state `1` and the 2nd in `3` then we have the state `q13`. 

We only accept when both of the machines are in an accept state. 

answer
[[IntersectionDFA.excalidraw]]

![[Pasted image 20230913112228.png]]
![[Pasted image 20230913112237.png]]
The language contains epsilon, and all strings which starts with any amount of a's and then any amount of b's. We cannot accept any a's after taking any b's

the DFA:
![[DFAab.excalidraw]]
The complement would then be the language where we accept on the last state instead of the two previous

![[Pasted image 20230913130349.png]]
easy: 
![[Pasted image 20230913130440.png]]

![[Pasted image 20230913130456.png]]
easy: ![[Pasted image 20230913130521.png]]


![[Pasted image 20230913130556.png]]
The language contains any combination of a string in A with a string in B. Since the empty string is also in this, as we use star, we can start in B as well. But we cannot just jump around in the strings in the two language, we have to follow them sequentially.

![[Pasted image 20230915121508.png]]

The states will be the product of the two states
the transition function, we can just choose if we want to use the one in A or in B. If we take the one in A we move forward in A else we move forward in B.

The accept states are gonna be the product of the two accept states, as both has to accept, i.e we have to be done with both strings.
![[Pasted image 20230915121634.png]]
In the transition function we can see that either we continue in A or in B, and we still keep track of the state in the other language

![[Pasted image 20230913130609.png]]
Have two boxes in which we have removed the accept states in the first, and when we meet the symbol we want to skip, we have epsilon to the box which has accept states. This way we **have** to jump if we want to accept the string.
![[Pasted image 20230915122431.png]]

In the formal proof we have
![[Pasted image 20230915124033.png]]
`states`: Q x {0,1} indicating whether we are in the first box or the accepting box.
`transition function`: 
1. When the read symbol is not epsilon we just take the transition function and we stay in the same state. 
2. When the symbol is epsilon we have a state for each of the ways of taking the path for `c` and

![[Pasted image 20230918122418.png]]
a. NFA which for each machine allows for going to the machines on the empty strings and allows to go back as we can repeat as many times we want

Remember that the empty set is part of every set
**We dont need to take into consideration all of the possibilites as each of the languages are described with an NFA, meaning we dont need to know what fx state 2 does on a 1 as it does not has to be deterministic**
![[NFA_union.excalidraw]]

b.
Start of by calculating how many states you can reach from the start state with epsilon transisitions
{1,2,3,6,10}
Next we need to check what each of the states does on a {0,1, $\epsilon$}

When we have converged we add accept states to all of the states that were accept states
Remember to follow the epsilon and add them to each state
See that `5, 9, 13` are redundant accept state since state `2` accepts
![[Pasted image 20230919104827.png]]
![[NFA_1.17b]]


![[Pasted image 20230918124408.png]]
![[Pasted image 20230918124434.png]]
**These are not regular expressions, they should be mathematical definitions**
a. \^10
b. (0|1)\*111\[01\]*
c. \[01\]\*0101\[01\]\*
d. \[01\]{2}\0\[01\]\*
e. 0(\[01\]{2})\*|1
f.\[01\]\*(^(110))\[01\]\*
g. (^(\[01\]{6,}))
	$(\sum\ union \ \epsilon)^5$
h. 
j. 00^+ union 100\^+ union 0\^+01 union 0^+10^+


![[Pasted image 20230918133959.png]]
b.
![[1-19b.excalidraw]]
![[Pasted image 20230919110233.png]]

![[Pasted image 20230918135351.png]]
h.
- accept
	- a
	- ba
- decline
	- b
	- $\epsilon$

![[Pasted image 20230918135652.png]]
make a new start state and accept state, all the previous accept states gets an empty string transition to the new accept state
and need to make all possible arrows to all states. Can use the empty set.

Sequentially remove the states one by one by `ripping` them out
![[NFA_to_regex.png]]

![[Pasted image 20230919114757.png]]
Make the previous start state accept and make the accept states be the new start states, then reverse the arrows
![[Pasted image 20230919115217.png]]

![[Pasted image 20230919115321.png]]
![[Pasted image 20230919121426.png]]
