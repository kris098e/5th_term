- `nullable:` can derive the empty string from the rule.
- `FIRST:` here we still look at the left-hand side, and see which terminals we can end with
- `FOLLOW:` here we look at the non-terminal (fx find `S` on the right-hand side, and follow this) on the `! right-hand side !` and see which terminals we can get
	- Look at the example below. Since `S` is nullable we have the following
		- For `X` we see that `S` is nullable, meaning we can have the entire right hand side and reduce when just having `X`, therefore we can also `FOLLOW(S)`, and ofc right after `X` we can find `S`, so we have to add the `FIRST(S)`.
			- The same thing happens for `E`. Since when we have gotten `E` on `rule 5`, then we can reduce on the rule. Therefore we can take the `FOLLOW(X)` for `E`.
			- do note that in `FOLLOW(S)` we do not add `FOLLOW(X)` when looking at `rule 5` since `E` is not nullable. If it were, we could add `FOLLOW(X)` to `FOLLOW(S)`.
		- for `B` we see that `S` is nullable, meaning we can also go onto `E` and take the `first(E)`. We can of course also get the `first(S)`, as these are the terminals we can get from `S`.
![[Pasted image 20231005145633.png]]
![[Appel-3-5.excalidraw]]
- nullable
Remember that $S'$ is not nullable, since it cannot just dissapere/derrive the empty string. 
B is not either, since it cannot just dissapere it has a lot of terminals
- first (easy)
- follow
	- just go through all the rules, and fx for S, add the first that can come first after the rule
		- rule `5`, we get `E` after S.
	- remember to add the first of the rule after the one following right after the rule, if the one right after is null.
		- consider rule `5`. Follow of B, since S is nullable, we also have to add First(E) to the set
	- When we are at the end of the rule, fx follow(E) we add follow of what is on the left hand side of the rule, so we add follow(X)
		- we do this, because fx when we reduce, we will have what is on the left hand side of the rule left, meaning that what follows `X` will also follow `E`
	- **Follow(X) contains Follow(S), since on rule `2` we can derive the empty string from `S`, meaning we have to add Follow(S).**

![[Pasted image 20231010085848.png]]
For each of the rule, perform the rule above
we add the rule to the number for the rule in the table
**Explanation of the above-constructed table**
> For each of the rules we have, we perform what is stated in the picture
> > This means we for each of the nonterminals X, enter in the row for the non-terminal X, the number of the rule for each of the terminals that is in the FIRST(X).
> > For the follow-part, we find the rule/production that makes this non-terminal nullable. We enter the number for this rule in the row corresponding to the non-terminal, for each of the columns/terminals where the terminal is in the follow of this non-terminal.
> 
> What these entries essentially mean is with this nonterminal, we can get to the terminal with the following rules
> > With the FIRST(X) we get how we immediately can get it with the left-hand side
> > With the FOLLOW(X) we get how we can get it during a production of some other nonterminal

**Table:**
The table created is not `LL(1)`, since we have multiple entries in some of the columns. 
> this means, that the grammar is NOT LL(1), but the table created is just fine


![[Pasted image 20231005151002.png]]
![[Appel-3-14.excalidraw]]

![[Pasted image 20231010094150.png]]
![[Pasted image 20231010094219.png]]
![[Appel-3-8.excalidraw]]
remember that when we fx are in `state 1` and we reduce with some rule, we go back to the state before reducing and see which state we should go to. 
**example, read $\epsilon \$$**:
1. start with state `1`.
2. we reduce with `3`. Now we have the string in the input $_{1}S$.
3. we go back to state 1 and see what we should do on S, which is go to sate 2
4. if we now read in `$` then we accept, else we get the state $_{1}x$.

**anoter example, have the indput xx$**
1. start with state `1`.
2. we reduce with rule `3`. have the string $_{1}S$
3. we go to state 1, and see on an S we go to state 2.
4. we read in an x and shift. Have the string $_{1}x_{3}$
5. the next thing on the input is an x, so on the lookahead symbol we reduce with rule `2`. This gives us the string $_{1}S$. 
6. we go to state `2` again, and read in the x, shifting giving us $_{1}x_{3}$ again. 
7. the next symbol we can see is $ and we reduce with rule `2` giving us $_{1}S$.
8. go to state 2, and accept since the lookahead is $.

# Important
The reason why we have `x` in the lookahead in the first state for the two rules, is because we have to execute the rule for `S` and the first(S) in fx rule 2, is `x`. Therefore we add the `x` to it as well.

We could also write more out, having the 2nd and 3rd with only the lookahead symbol $ since these closes from the 1st rule. and the `x` comes from closing the 2nd rule, where we can write this up as a 4th and 5th rule, having only the lookahead symbol `x` for these rules
## Further
When you are at the end of a production and you cannot read anything more in, then when you see one of the lookahead symbols, then you will use a rule to reduce.

when using right recursion, we can only reduce at the end, meaning we have to read in all of x's that there are there, and first then we can reduce.
If using left recursion, we can reduce after each read x, meaning the stack will be much smaller.

# Doing the right recursion
![[Pasted image 20231013103144.png]]
# 3.10
![[Pasted image 20231013101629.png]]
![[Pasted image 20231013103254.png]]
- remember we added the `id` to the lookahead symbols of the last closure of `P` since `id` is in the first of `G`.
![[Pasted image 20231013104951.png]]
## Conflicts
see fx. in the top left most right box. We can either choose to reduce with `rule 4` when we see `id`. Else when we see `id` we can also shift with `rule 5`.
# 3.12
![[Pasted image 20231013101701.png]]
d. if there are any conflicts in the parsing table, then it is not an LR(1) grammar

![[Pasted image 20231013101710.png]]
Just combine the states which has the same productions, but they dont actually have to have the same lookahead symbols. We just append the lookahead symbol
## How to do the exercise
start by making the LR(1) of the grammar.
remember to start out with all the rules that has the only the start symbol on the left side. So all rules with `S` 

- in the 2nd state:
	- on the first rule `S->(.X ?` we do first of `nothing` and `?` meaning the rules when we do the closure on `X` will get the lookahead symbol of `?` 

end up getting `reduce/reduce`-conflicts, since we can reduce with two different rules. Can both reduce with `E->A.` and `F->A.` when reading `),]`  
![[Pasted image 20231013114221.png]]

