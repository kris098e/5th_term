![[Pasted image 20231005145633.png]]
![[Appel-3-5.excalidraw]]
- nullable
Remember that $S'$ is not nullable, since it cannot just dissapere/derrive the empty string. 
B is not either, since it cannot just dissapere it has a lot of terminals
- first (easy)
- follow
	- just go through all the rules, and fx for S, add the first that can come first after the rule
		- rule `5`, we get `E` after S.
	- remember to add the first of the rule after the one following right after the rule, if the one right after is null.
		- consider rule `5`. Follow of B, since S is nullable, we also have to add First(E) to the set, since S can derrive the empty string.
	- When we are at the end of the rule, fx follow(E) we add follow of what is on the left hand side of the rule, so we add follow(X)
		- we do this, because fx when we reduce, we will what is on the left hand side of the rule left, meaning that what follows `X` will also follow `E`
	- **Follow(X) contains Follow(S), since on rule `2` we can derive the empty string from `S`, meaning we have to add Follow(S).**

![[Pasted image 20231010085848.png]]
For each of the rule, perform the rule above
we add the rule to the number for the rule in the table

**Table:**
The table created is not `LL(1)`, since we have multiple entries in some of the columns. 
> this means, that the grammar is NOT LL(1), but the table created is just fine


![[Pasted image 20231005151002.png]]
![[Appel-3-14.excalidraw]]

![[Pasted image 20231010094150.png]]
![[Pasted image 20231010094219.png]]
![[Appel-3-8.excalidraw]]
remember that when we fx are in `state 1` and we reduce with some rule, we go back to the state before reducing and see which state we should go to. 
**example, read empty string**:
1. start with state `1`.
2. we reduce with `3`. Now we have the string in the input $_{1}S$.
3. we go back to state 1 and see what we should do on S, which is go to sate 2
4. if we now read in `$` then we accept, else we get the state $_{1}x$.

**anoter example, have the indput xx$**
1. start with state `1`.
2. we reduce with rule `3`. have the string $_{1}S$
3. we go to state 1, and see on an S we go to state 2.
4. we read in an x and shift. Have the string $_{1}x_{3}$
5. the next thing on the input is an x, so on the lookahead symbol we reduce with rule `2`. This gives us the string $_{1}S$. 
6. we go to state `2` again, and read in the x, shifting giving us $_{1}x_{3}$ again. 
7. the next symbol we can see is $ and we reduce with rule `2` giving us $_{1}S$.
8. go to state 2, and accept since the lookahead is $.

# Important
The reason why we have `x` in the lookahead in the first state for the two rules, is because we have to execute the rule for `S` and the first(S) in fx rule 2, is `x`. Therefore we add the `x` to it as well.

We could also write more out, having the 2nd and 3rd with only the lookahead symbol $ since these closes from the 1st rule. and the `x` comes from closing the 2nd rule, where we can write this up as a 4th and 5th rule, having only the lookahead symbol `x` for these rules
## Further
When you are at the end of a production and you cannot read anything more in, then when you see one of the lookahead symbols, then you will use a rule to reduce.

when using right recursion, we can only reduce at the end, meaning we have to read in all of x's that there are there, and first then we can reduce.
If using left recursion, we can reduce after each read x, meaning the stack will be much smaller.

# Doing the right recursion
![[Pasted image 20231013103144.png]]
# 3.10
![[Pasted image 20231013101629.png]]
![[Pasted image 20231013103254.png]]
- remember we added the `id` to the lookahead symbols of the last closure of `P` since `id` is in the first of `G`.
![[Pasted image 20231013104951.png]]
## Conflicts
see fx. in the top left most right box. We can either choose to reduce with `rule 4` when we see `id`. Else when we see `id` we can also shift with `rule 5`.
# 3.12
![[Pasted image 20231013101701.png]]
d. if there are any conflicts in the parsing table, then it is not an LR(1) grammar

![[Pasted image 20231013101710.png]]
Just combine the states which has the same productions, but they dont actually have to have the same lookahead symbols. We just append the lookahead symbol
## How to do the exercise
start by making the LR(1) of the grammar.
remember to start out with all the rules that has the only the start symbol on the left side. So all rules with `S` 

- in the 2nd state:
	- on the first rule `S->(.X ?` we do first of `nothing` and `?` meaning the rules when we do the closure on `X` will get the lookahead symbol of `?` 

end up getting `reduce/reduce`-conflicts, since we can reduce with two different rules. Can both reduce with `E->A.` and `F->A.` when reading `),]`  
![[Pasted image 20231013114221.png]]

