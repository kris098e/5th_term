1. Run the hand-coded factorial on paper, registering all content of the stack and in the registers. There will be a lot of small values (especially ones), so include notes as to what the values represent. In the example, the argument to `fac` in the main program is 5. You should use a smaller value (at most 2).
2. Make a similar hand-coded implementation of the computation of Fibonacci numbers, fib(n), where fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2), n > 1. You may have implemented Fibonacci before in other courses, but the point is to do it using a stack-frame layout that will help you understand the SCIL compiler.
3. Compare the hand-coded version of factorial with the one produced by SCIL. Identify the differences and explain them. In particular, compare with the stack frame from the lecture and discuss which parts have been omitted in the hand-coded version.
4. There should be extra time after you have completed these exercises, which are to some extent repetition of machine architecture, with the primary aim of laying the foundation for the more interesting exercises for next time. Start on the problem for next time today since there should be extra time and likely too little time at the next exercise session.


- Ask questions to your TA about the SCIL compiler. As preparation, review the purpose of each phase of the compiler as represented by the files in the curriculum. Understand the structure of each file and get an overview. Look at selected details with largest emphasis on `code_generation.py`. Ask about things you do not understand. For the latter, it would be an advantage to draw a stack frame on the blackboard to use as a reference point.
- Catch up on exercises if any have been skipped due to time contraints.