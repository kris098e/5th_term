# 1
1. Run the hand-coded factorial on paper, registering all content of the stack and in the registers. There will be a lot of small values (especially ones), so include notes as to what the values represent. In the example, the argument to `fac` in the main program is 5. You should use a smaller value (at most 2).
- just about seeing how we move the base pointer `%RBP` around. 
- Also notice how we push the line to return to indirectly when calling.
# 2
1. Make a similar hand-coded implementation of the computation of Fibonacci numbers, fib(n), where fib(0) = 0, fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2), n > 1. You may have implemented Fibonacci before in other courses, but the point is to do it using a stack-frame layout that will help you understand the SCIL compiler.
- using the stack again is important. Moving `%RBP` a lot, and using it for results
# 3
2. Compare the hand-coded version of factorial with the one produced by SCIL. Identify the differences and explain them. In particular, compare with the stack frame from the lecture and discuss which parts have been omitted in the hand-coded version.
- A lot of extra code / lines, since we follow conventions of callee-save-registers and caller-save-registers. 
	- Also fx instead of `movq` we will push it and then pop it into another register.
	- Much additional work is done for formality, to ensure invariants.
# 4
1. There should be extra time after you have completed these exercises, which are to some extent repetition of machine architecture, with the primary aim of laying the foundation for the more interesting exercises for next time. Start on the problem for next time today since there should be extra time and likely too little time at the next exercise session.

# 5 
1. Extend SCIL with a new construction
    
    **repeat** 〈statement_list〉 **until** 〈expression〉 **;**
    
    You must go through all the relevant phases. You can get significant inspiration from considering the while-loop equivalent.
same as `do-while`
## Phases
### Lexer / parser
- To match on the expression
- To create AST node `stm_repeat`
#### AST
```python
@dataclass
class statement_repeast_until:
    exp: Any
    repeat_part: Any
    lineno: int

    def accept(self, visitor):
        visitor.preVisit(self)
        self.repeat_part.accept(visitor)
        self.exp.accept(visitor)
        visitor.midVisit(self)
```
### Code generation
Dont have to add to the other phases, as we have implemented a `statement_list, expression`.
- The node looks like a `while-loop`.
Now we we just need to implement the visitors in the code generation.
# 6
1. It is a little annoying to have to declare a variable and write `dummy = f()` in situations where we do not really want the function to return any value. Change this in SCIL by allowing an expression as a statement. It is ok (and easiest) to still require that all functions return a value. At the point where you now _do not_ use the value, you should remember to pop it off the stack.
- add it to the statements, make a new node for when having functions on the right hand side. Add some additional info to the node, whenever it is a statement instead of a call.
# 7
1. Discuss how to add break and continue statements to while-loops so they can be used as illustrated below, where we add positive values from an array until reaching the (stop) value zero.
    
    i = -1;
    sum = 0;
    while i+1 < length(A) do {
       i += 1;
       if A[i] == 0 then break;
       if A[i] < 0 then continue;
       sum += A[i];
    }
    
    Discuss what would be needed in the different phases of SCIL to add this feature. (Note that the motivating program example is not a SCIL program, but this is irrelevant for the discussion of how to add the feature, and we just assume that SCIL already has arrays, etc.)
    
    After this discussion, consider nested while-loops using these features. How should it work, and does your solution supply the right functionality?
- add `break, continue` inside of the statements (`statement_ifthenelse, statement_while`), in the lexer.
# 8
1. Discuss what should be done in the different phases if we wanted to add the type boolean and allow the operators and, or, and not.
	1. add the tokens for the operations `and, or, not, bool`
		1. add to precedence. `and, or, not`
			1. the lowest has the strongest precedence
```python
precedence = (
    ('right', 'EQ', 'NEQ', 'LT', 'GT', 'LTE', 'GTE'),
    ('left', 'PLUS', 'MINUS'),
    ('left', 'TIMES', 'DIVIDE'),
)
=>

precedence = (
	('left', '!', '|', '&'),
    ('right', 'EQ', 'NEQ', 'LT', 'GT', 'LTE', 'GTE'),
    ('left', 'PLUS', 'MINUS'),
    ('left', 'TIMES', 'DIVIDE'),
)
```
1. make a function for the token
	1. match on `r'\"true|false\"'`
	2. make the nodes value a `python_bool`
body looks like
```python
def p_body(t):
    'body : optional_variables_declaration_list optional_functions_declaration_list statement_list'
    t[0] = AST.body(t[1], t[2], t[3], t.lexer.lineno)
```
so we would possibly need an `optional boolean declaration list`
or change the `optional variables declarion list` to also allow for booleans.

in the `AST` we will need a node for the `BOOL`, just like the `expression_integer`

- `type checking` we would have to do something, fx if we have calculations between integers, we need to check that both sides are integers. This would also be the case for booleans.
- also for `symbols` when collecting booleans
- We will need to touch upon `code generation`. Look at the integer code generation.
## Discuss how C-style for-loops could be added to SCIL via syntactic sugar.
For loops looks like a while loop. 
- lexxer match on `FOR LPAREN assignment SEMICOL expression SEMICOL statement RPAREN LCURL statement_list RCURL`

We will turn into into a while loop, so in the code generation we will have
1. assignment
2. while expression
3. BODY
4. statement

## Some of the above exercises only ask for discussions of how to implement a feature in SCIL. Though it may not be covered at the exercise class, implementing any of the above-mentioned extra features in SCIL will of course only boost your understanding of compiler construction.

# 9
- Ask questions to your TA about the SCIL compiler. As preparation, review the purpose of each phase of the compiler as represented by the files in the curriculum. Understand the structure of each file and get an overview. Look at selected details with largest emphasis on `code_generation.py`. Ask about things you do not understand. For the latter, it would be an advantage to draw a stack frame on the blackboard to use as a reference point.
# 10
- Catch up on exercises if any have been skipped due to time contraints.
