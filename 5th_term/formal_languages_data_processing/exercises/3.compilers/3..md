# 1
1. Consider allowing that the same identifier is used for a variable and a function in the same scope, i.e., one could in principle have a function call that looked like `f(f)`. Discuss if it is possible to handle this and which changes should be made in SCIL to allow this if it is possible. Then consider if we could reasonably allow local variables in a function and formal parameters to have the same name
	1. It is possible to handle this, type checking will have to allow it
	2. Symbol collection should support functionality for an identifier to be both a function and variable at the same time.
		1. in `previsit_function()`, we dont allow duplicates of the name for the function. This should be changed

	3. we cannot allow this, as we would not be able to distinguish which variable is used, when using the variable. Would it be the local or the formal.
		1. else we will have to define some priority of which to use, and always override 1 of them
# 2
1. Consider the construction (written in a style corresponding to the right-hand side of a grammar rule)
    signtest(E){
       neg:  S
       zero: S
       pos:  S
    }
    
    The intention is that the expression `E` is evaluated and depending on the sign, one of three statements are executed. Consider which changes should be made in a compiler for the phases scanner, parser (AST), symbol collection, and type checking.
> remember every case has to be implemented, but only ran once

# 3
## Scanner
1. make `Signtest` a `%token`
	1. like `main` in the compiler
2. match on `SIGNTEEST LPAREN exp RPAREN LCURL NEG COL statement ZERO COLON statement ... RCURL`
	1. have to create all of the cases, as they should be able to be executed. i.e no `|` statement
## Symbol collection
dont have to do anything?
## Code generation
1. `previsit` define a label, fx `statement_start{uniq}`
2. `premidvisist` generate code that compares `exp 0`
	1. if < 0 then `je` NEG
	2. if = 0 then `je` POS
	3. ...
	4. generate label for `NEG`
3. `midvisit`
	1. generate code for `NEG`
		1. remember to `jmp` down to `statement_end{uniq}` which is generated whenever we are done with creating the last label
	2. create label for `ZERO`
4. `postmidvist`
	1. generate code for `ZERO`
		1. remember to `jmp`....
	2. generate label for `POS`
5. ...
6. `lastly`
	1. generate label for `statement_end{uniq}`
# 4
8. In SCIL, all functions must execute a return before terminating. However, such a return statement does not necessarily have to be located as the last statement in a sequence; it could, for instance, be placed in both branches of an if-then-else statement, or, in principle, just in one branch of an if-then-else statement, if we are certain that that branch will always be executed. Assume that we are interested in giving the user a warning if we think it is possible a return statement has been forgotten. Discuss what a reasonable strategy would be. Assume we implement this in SCIL in a separate phase. Consider representative language constructions and discuss what code to write in order to implement this feature.
	1. ![[Pasted image 20231023144116.png]]
	2. We would in the node for the `ifthenelse` traverse through all of the nodes for the `statement` and check if there are `return`, if we the function does not have return. If there is not a return statement in all of the `if then else` then we will warn
## in class
- Could make a new visitor which goes through the `AST` which when encountering a function we have a boolean variable, which is set to `false` signailling we dont have a correct function since we did not meet a return statement. If we meet a `return` then we will set it to true. Then when leaving the function we set it to false again, when we get back into the other function. 
- If we leave a function without the variable being `true` then it is not valid
# 5
9. Consider a construction such as
    
    for (i = 1; i < 100; i++){
       S
    }
    
    Some programming languages will forbid changing the loop variable inside the loop, i.e., it is OK if `S` is `print(i)` or `A[i] = i*i`, but `i = 42` or `i -= 1` should be forbidden. What would be a good way to organize this check in the symbol collection / type checking phases?
	- When we go into a `while, for` we will mark the variable as some `type loop_variable`, and we cannot modify it.
	- have to think about if we used the variable before or not. If we did then we will revert it back to a modifiable variable.
# 6
1. In the type checking phase, we want to verify, among other things, that functions are called with the right number of parameters. Think about how you would do this for a function call `f(1, 2, 3)`. What are the steps the compiler should go through? Does your method also work for, for example, `f(0, 1, f(2, f(3, 4, 5), 6))`? How is this handled in SCIL?
- for only counting variable, we just count `commas` and then `+1`
- if we deal with both variables and functions, we can do it recursively, i.e when we meet a function in the parameters we will just start checking that function, ensuring all the functions as the parameters is called correctly. So when we finish the recursion we have checked that all of the parameters are called correctly.
## SCIL
- [0]
- [1]
- [2]
- 
enter the function
- [2,0]
- [2,1]
new function
- [2,1,0]
- [2,1,1]
- [2,1,2]
- [2,1,3]
Check if the top of stack has the correct amount of parameters (`postvisit_expression_call`)
>pop 3

- [2,1]
- [2,2]
- [2,3]
check again, pop it

- [2]
- [3]
check again, pop, done
- []

# 7
1. Change the scope rules of SCIL so that functions can only access their own variables or variables in the main scope. We still allow writing nested functions. Change the `lookup` function in `symbols.py` to make that change. Verify that the compiler still works fine for some programs such as `factorial.src`. Observe that the compiler also works for a program such as `static_nested_scope.src`, but now it works differently. Write a SCIL program that works with the original compiler, but is rejected after your change.
