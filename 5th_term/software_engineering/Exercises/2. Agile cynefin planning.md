# 1 Agile vs agile

What is the different between ‚ÄúAgile‚Äù and ‚Äúagile‚Äù other than the obvious casing?

Why is this an important distinction?

## Answer
The difference between "Agile" and "agile" extends beyond just their casing and involves distinct concepts in different contexts:

1. **Agile (with a capital 'A'):**
    
    - **Agile Manifesto:** Agile, when capitalized, typically refers to the Agile Manifesto. The Agile Manifesto is a set of guiding values and principles for software development that prioritize customer collaboration, flexibility, and iterative development. It was created by a group of software developers in 2001 and has since become a foundation for Agile methodologies.
        
    - **Agile Methodologies:** Agile methodologies, such as Scrum, Kanban, and Extreme Programming (XP), are specific approaches to software development that are based on the principles outlined in the Agile Manifesto. These methodologies provide frameworks and practices for teams to work collaboratively, adapt to changing requirements, and deliver valuable software incrementally.
        
    - **Project Management:** Agile, in a project management context, refers to an approach that emphasizes flexibility, collaboration, and incremental progress. It's used in various industries beyond software development to manage projects and adapt to changing circumstances.
        
2. **agile (with a lowercase 'a'):**
    
    - **Adjective:** When written in lowercase, "agile" is an adjective that describes the ability to move quickly and easily, be flexible, and adapt to changing situations. It's a general term that can be applied to various domains, not limited to software development or project management.
        
    - **Not Necessarily Related to Agile Manifesto:** se used in the context of Agile software development methodologies, it doesn't necessarily imply adherence to the specific principles and practices outlined in the Agile Manifesto. It can be used more broadly to describe any approach or organization that values flexibility and adaptability.

In summary, the difference between "Agile" and "agile" is not just a matter of casing but also involves distinct meanings and contexts. "Agile" with a capital 'A' refers to a specific set of principles and methodologies outlined in the Agile Manifesto, often related to software development and project management. On the other hand, "agile" with a lowercase 'a' is a more general adjective used to describe the ability to be flexible, adaptable, and responsive, which can be applied across various domains.

# 2 The Manifesto for Agile Software Development

Why did the authors of the manifesto include:

> That is, while there is value in the items on the right, we value the items on the left more.

Individuals and interactions    |   over   |   processes and tools
Working software                    |   over   |   comprehensive documentation
Customer collaboration           |   over   |   contract negotiation
Responding to change            |   over   |   following a plan

What are the implications of this?

1. Tool is useless without the correct individual
	1. Interractions will ensure that everyone understands correctly what is to be build, and **how** to do it. Meaning we wont end up with just 20 different coding styles, still having split the product as no other individual understands the code
2. If the software works then we dont need documentation.
	1. it still has to be good software and easy to read, else we will need to have documentation. Here we need the interractions, to have readable software and an agreeement
3. Since customers are prone to come with changes, if we can adapt to it instead of just refer to the set contract, then we are also more likely to get customers
4. Look at 3, also fx in libraries we need to change frequently

What would happen if we simply omitted this? Or reversed it?
If we reversed it then we have planning structure, where we cannot adapt and be flexible. 
We would be prone to go over time on projects as the final plan can end up looking a lot different than the initial

# 3 Fixed Mindset
Describe the properties of an ‚ÄúFixed Mindset‚Äù.
![[Pasted image 20230913103256.png]]

Not able to improve

**In software based solutions** fx if we have a contract with a customer and the customer wants something to be changed, we wont allow it. Also fx if we have some bad code, we dont want to refractor it since it works as it is

Overall being `fixed` 
# 4 Agile Mindset
Describe the properties of an ‚ÄúAgile Mindset‚Äù.

Being adaptive and flexible to situations. You value what is described in the Agile manifesto
Meeting failures with gratitude, since you can improve

Meeting challenges with a `hard cock`
# 5 Growth Mindset
People often talk about we need to have an ‚ÄúAgile Mindset‚Äù. What defines an ‚ÄúAgile Mindset‚Äù? What are the relation to the ‚ÄúGrowth Mindset‚Äù?
Can you find examples of Growth Mindset in being a student at SDU?

Ready to grow from your everyday as a person, where you as "Agile mindset" is more work project oriented

Having a tough course, you still show up and do the workü¶ç  and learn from it 
## Additional notes
An agile mindset may be a requirement for an entire team to have, but the individuals can themselves have the growth mindset

# 6 Agile Principles
Underneath the values in the Agile Manifesto, 12 principles were created to align people.
- How do we measure progress in Agile projects compared to Waterfall projects? What are are the major differences, and why?
	1. AGILE: how much working software
	2. WATERFALL: how much documentation you have checked off
- What are the changes in communication in an Agile project compared to Waterfall Projects?
	1. AGILE: you interact with your peers, and different teams
	2. WATERFALL: you read the documentation, you dont interact with other teams as your job is just to follow the documentation the other teams has made
- How does the Agile Principles describe architecture?
	1. Communication with other teams, face to face communications, less dependency on a leader.
	2. The architecture that fits the team best.
		1. It itself emerges, what is best for the team

# Agile Principles Outside IT
Rewrite the Agile Principles to Product Oriented principles instead.
Rewrite it to be for any product, not just software based solutions


1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
	1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable product.

2. Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.
	1. 

3. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.

Business people and developers must work
together daily throughout the project.

Build projects around motivated individuals.  
Give them the environment and support they need,  
and trust them to get the job done.

The most efficient and effective method of  
conveying information to and within a development  
team is face-to-face conversation.

Working software is the primary measure of progress.

Agile processes promote sustainable development.  
The sponsors, developers, and users should be able  
to maintain a constant pace indefinitely.

Continuous attention to technical excellence  
and good design enhances agility.

Simplicity--the art of maximizing the amount  
of work not done--is essential.

The best architectures, requirements, and designs  
emerge from self-organizing teams.

At regular intervals, the team reflects on how  
to become more effective, then tunes and adjusts  
its behavior accordingly.


How much needs to change? Does this change the value of the principles?

# 7 Get Ready for Agile Methods, With Care
In this article by Barry Boehm we read about his view on when Agile makes sense.

In Table 1 Boehm describes several factors that determines when Agile works. Go through the table, claim by claim and construct either supporting arguments or find rebuttle arguments for each of the claimsX

![[Pasted image 20230913110257.png]]
**Developers**: Ofc need to be collocated, but if they are not knowledgable they dont have time to think about how to move forward. In plan oriented they have time to access external knowledge.

**customers**: need to be collocated for quickly getting information, instead of having to travel to different location as we need to be adaptive. Need empowered customers, as we dont want to speak with everyone as we dont have time for it. In **plan-driven** we would want customers that know more what they want in the present, as we cannot change the requirements

**requirements** just makes sense

**Architecture** also just makes sense, if we know everything early and that no changes will occur during the process then we can just plan it

**Size**: if we have larger teams which cannot communicate as easily we need to plan, such that the others can move forward with the expectation that the others follows the plan

**Primary objective**: In a plan-driven development we may not have a working product before we are done. And in Agile we are adaptive and working software is the objective, meaning we want to provide rapid value.

# 8 Cynefin
- Construct questions, actions or experiments that can help you validate if you are in the:
    - Obvious Domain
    - Complicated Domain
    - Complex Domain
    - Chaotic Domain

- Find examples from Computer Science that fits in each of the four domains
- Using The Planning Spectrum where would the different methodologies fit into the Cynefin Framework?
- Why cant we use the term ‚ÄúBest Practices‚Äù in the majority of software development?


To validate which domain you are in within the Cynefin Framework (Obvious, Complicated, Complex, or Chaotic), you can use various approaches:

**1. Obvious Domain:**

- **Question:** Are the problems and solutions straightforward and widely understood?
	- Can you google it?
- **Action:** Apply well-established rules or standard procedures.
- **Experiment:** Test the known solution to see if it works as expected.
- **Example in Computer Science:** Syntax checking in a compiler is a straightforward and well-understood task. If the code follows the language rules, it's valid.

**2. Complicated Domain:**

- **Question:** Are there multiple possible solutions, and experts are needed to analyze and choose the best one?
	- Do I have an idea of what the problem is?
- **Action:** Seek expert advice, conduct in-depth analysis, and use known methodologies.
- **Experiment:** Evaluate different algorithms or design patterns to determine the most efficient one.
- **Example in Computer Science:** Optimizing an algorithm for a specific use case may require expertise and analysis to choose the most efficient approach.

**3. Complex Domain:**

- **Question:** Is the problem unpredictable, without certain experiments first, with many interdependencies and no clear cause-and-effect relationship? 
	- Do I need to probe it to multiple experts, such that they can come up with a solution?
	- Do I not know a possible solution beforehand
	- Do I need to ask multiple experts?
	- Does a new solution need to be created?
- **Action:** Encourage experimentation, probe for solutions, and foster a culture of learning.
- **Experiment:** Implement small changes and observe their impact on the system as a whole.
- **Example in Computer Science:** Developing a recommendation system where user preferences are constantly changing and influenced by various factors, making it a complex, adaptive problem.

**4. Chaotic Domain:**

- **Question:** Is the situation in a state of chaos with no discernible patterns or control? Do you have no idea on how to move forward?
	- Do you even know what you dont know?
- **Action:** Stabilize the situation, impose order, and take immediate actions to contain the chaos.
- **Experiment:** Implement rapid interventions to restore order and identify potential solutions.
- **Example in Computer Science:** Responding to a sudden cybersecurity breach or a critical system failure requires immediate containment and damage control.

Regarding the Planning Spectrum and its alignment with the Cynefin Framework:

- **Simple/Obvious Domain:** This aligns with a more traditional, Waterfall-style planning approach where requirements are well-defined, and a detailed plan is created upfront.
    
- **Complicated Domain:** Here, a more iterative and planned approach, like the Rational Unified Process (RUP) or some aspects of Agile, can be effective. Expertise is required to analyze and determine the best course of action.
    
- **Complex Domain:** Agile methodologies, particularly Scrum, align well with the Complex Domain. They promote experimentation, frequent feedback, and adaptability to address unpredictable and evolving situations.
    
- **Chaotic Domain:** In a Chaotic Domain, you would rely on immediate action and firefighting rather than planning. Post-incident analysis and learning become crucial to prevent future chaos.

As for the term "Best Practices" in software development, it's not universally applicable due to the nature of the field:

- **Rapid Technological Change:** Software development is highly dynamic, with new technologies and practices constantly emerging. What's considered a "best practice" today may become outdated tomorrow.
    
- **Diverse Contexts:** Software projects vary widely in terms of scope, technology stack, team dynamics, and user needs. What works as a best practice in one context may not be suitable in another.
    
- **Subjectivity:** Best practices often depend on subjective judgments, and what's best for one team or project may not be the same for another. It's essential to tailor practices to specific circumstances.

Instead of seeking "best practices," it's often more valuable to focus on "good practices" or "context-specific practices" that are suitable for a particular project or organization's needs. Experimentation and adaptation should be encouraged to find what works best in a given context.





in regards to the model
- `Hackers`: would be chaotic, you try something and hope it works
- `XP`: In the medium between simple and complicated, but mostly in complicated. Simple when you just push to master, and when you have to be more cautious you have to be in the complicated zone
- `Agile-methods`: In complicated most of the time to improve and respond quickly, but you also have to invite complexity so you also have to be in the complex state
- `Planning`: Abit same of agile but you can accept being more in the complex zone since you have the time to probe