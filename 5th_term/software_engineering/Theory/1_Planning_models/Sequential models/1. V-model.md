https://www.geeksforgeeks.org/software-engineering-sdlc-v-model/

Be able to test the flow by going only a few steps back instead of the entire way **shorter feedback loops**
More testing, visualizing where and how to go back


revisits decisions: goes back to the decisions made when testing the implementation, architecture ...

good examples of when to use: 
* Cooking (testing each ingredient once it is added to see if too much or not enough ...), 
* Medical equipment, 
* Physical product (hard to go back)
![[Pasted image 20230903155511.png]]

# Chatten
The V-Model, also known as the Verification and Validation (V&V) model, is a software development process that is an extension of the waterfall model. It's called the V-Model because of its shape representing the sequential flow of the steps involved. Each phase must be completed before the next phase begins, and there's a high level of emphasis on documentation and error detection in early stages. Here's a brief explanation of each phase in the V-Model:

### 1. Requirements Analysis (Validation Side)
- **What happens**: This is the first phase where requirements are gathered and analyzed to understand what the software needs to do.
- **Key Activities**: Defining user expectations, capturing system functionality, and preparing requirement specifications.

### 2. System Design (Validation Side)
- **What happens**: Based on the requirements, a system design is prepared. This defines the architecture, components, modules, and interface of the system.
- **Key Activities**: Developing high-level product architecture, identifying technological approach, and designing the overall system architecture.

### 3. Architectural Design (Validation Side)
- **What happens**: The architectural blocks of the software are defined. This includes breaking down the system design into smaller, more manageable modules or components.
- **Key Activities**: Further breaking down of system components, defining interrelations and interfaces between modules.

### 4. Module Design (Validation Side)
- **What happens**: Detailed internal design for all the system modules is specified, referred to as Low-Level Design (LLD).
- **Key Activities**: Defining algorithms, detailed database models, detailed layouts for each module.

### 5. Implementation (Central Part of the V)
- **What happens**: The actual coding of the software takes place. The system is built and units are developed and tested for their functionalities.
- **Key Activities**: Coding, unit testing, and integrating different modules.

### Verification Side (Corresponding Testing Phases)

Each of the aforementioned validation phases has a corresponding testing phase on the right side of the V, emphasizing the model's focus on testing:

### 6. Unit Testing
- **Corresponds to**: Module Design
- **What happens**: Each module is tested in isolation to ensure it meets the design specifications.

### 7. Integration Testing
- **Corresponds to**: Architectural Design
- **What happens**: Different modules are combined and tested as a group to expose faults in their interactions.

### 8. System Testing
- **Corresponds to**: System Design
- **What happens**: The entire system is tested as per the requirements to verify that the product behaves as intended.

### 9. Acceptance Testing
- **Corresponds to**: Requirements Analysis
- **What happens**: The software is tested with the real-world scenario and validated against the requirements by the end-users.

The V-Model supports a systematic and disciplined approach to software development. Each step is clearly defined, and it is particularly strong in ensuring that there's a direct relationship between a development stage and its associated testing phase. This model is very rigid and less flexible compared to other models like Agile, making it less adaptive to changes during the development process. However, it's quite effective in catching defects early in the process, making it a popular choice for projects where quality is more concerned over flexibility and adaptability.